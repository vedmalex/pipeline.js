{"version":3,"file":"index.js","sources":["../src/context.ts","../src/utils/ErrorList.ts","../src/utils/empty_run.ts","../src/utils/types.ts","../src/utils/can_fix_error.ts","../src/utils/errors.ts","../src/utils/process_error.ts","../src/utils/run_callback_once.ts","../src/utils/execute_callback.ts","../src/utils/execute_custom_run.ts","../src/utils/execute_ensure.ts","../src/utils/execute_rescue.ts","../src/utils/execute_validate.ts","../src/stage.ts","../src/utils/run_or_execute.ts","../src/dowhile.ts","../src/empty.ts","../src/ifelse.ts","../src/multiwayswitch.ts","../src/parallel.ts","../src/pipeline.ts","../src/retryonerror.ts","../src/sequential.ts","../src/timeout.ts","../src/wrap.ts"],"sourcesContent":["/**\n * Module dependency\n */\nimport { defaultsDeep, get, set } from 'lodash'\nimport { StageObject } from './utils/types'\n\nexport const ContextSymbol = Symbol('Context')\nexport const OriginalObject = Symbol('OriginalObject')\nexport const ProxySymbol = Symbol('Handler')\n\n/*!\n * List of reserver words for context.\n * Used to check wheater or not property is the Context-class property\n */\n\nexport enum RESERVATIONS {\n  prop,\n  func_this,\n  func_ctx,\n}\nconst RESERVED: Record<string, RESERVATIONS> = {\n  getParent: RESERVATIONS.func_ctx,\n  getRoot: RESERVATIONS.func_ctx,\n  setParent: RESERVATIONS.func_ctx,\n  setRoot: RESERVATIONS.func_ctx,\n  toString: RESERVATIONS.func_ctx,\n  original: RESERVATIONS.prop,\n  __parent: RESERVATIONS.prop,\n  __root: RESERVATIONS.prop,\n  __stack: RESERVATIONS.prop,\n  hasChild: RESERVATIONS.func_ctx,\n  hasSubtree: RESERVATIONS.func_ctx,\n  ensure: RESERVATIONS.func_ctx,\n  addChild: RESERVATIONS.func_ctx,\n  addSubtree: RESERVATIONS.func_ctx,\n  toJSON: RESERVATIONS.func_ctx,\n  toObject: RESERVATIONS.func_ctx,\n  fork: RESERVATIONS.func_this,\n  get: RESERVATIONS.func_this,\n  allContexts: RESERVATIONS.func_this,\n}\n\n// добавить время обработки ctx на процессоре\n// оптимизировать код, чтобы работал быстрее....\n// может быть где-то убрать где-то добавить.\n// контекст может быть массивом, не обязательно\n// весь объект инициализировать сделать внутреннее хранилище, для неизменяемости ссылки....\n\nexport type ContextType<T> = IContextProxy<T> & T\n\nexport interface IContextProxy<T> {\n  getParent(): ContextType<T>\n  getRoot(): ContextType<T>\n  setParent(parent: ContextType<T>): void\n  setRoot(parent: ContextType<T>): void\n  toJSON(): string\n  toObject(clean?: boolean): T\n  toString(): string\n  fork<C extends StageObject>(config: C): ContextType<T & C>\n  get(path: keyof T): any\n  get original(): T\n  [key: string | symbol | number]: any\n}\n\nvar count = 0\nvar allContexts: Record<string, Context<any>> = {}\n/**\n *  The **Context** itself\n *  @param {Object} config The object that is the source for the **Context**.\n */\nexport class Context<T extends StageObject> implements IContextProxy<T> {\n  public static ensure<T extends StageObject>(_config?: Partial<T>): ContextType<T> {\n    if (Context.isContext<T>(_config)) {\n      return _config as unknown as ContextType<T>\n    } else {\n      return new Context(_config ?? {}) as unknown as ContextType<T>\n    }\n  }\n\n  public static isContext<T extends StageObject>(obj?: any): obj is IContextProxy<T> {\n    return obj ? obj[ContextSymbol] : false\n  }\n\n  protected ctx: T\n  protected proxy: any\n  protected __parent!: ContextType<T>\n  protected __root!: ContextType<T>\n  protected __stack?: string[]\n  protected id: number;\n  [OriginalObject]?: boolean\n  get original() {\n    return this.ctx\n  }\n\n  constructor(config: T) {\n    this.ctx = config as T\n    this.id = count++\n    allContexts[this.id] = this\n    const res = new Proxy(this, {\n      get(target: Context<T>, key: string | symbol | number, _proxy: any): any {\n        if (key == ContextSymbol) return true\n        if (key == ProxySymbol) return _proxy\n        if (key == 'allContexts') return allContexts\n\n        if (!(key in RESERVED)) {\n          if (key in target.ctx) {\n            return (target.ctx as any)[key]\n          } else {\n            return target.__parent?.[key as any]\n          }\n          // return (target.ctx as any)[key]\n        } else {\n          if (RESERVED[key as keyof typeof RESERVED] == RESERVATIONS.func_ctx) {\n            return (target as any)[key].bind(target)\n          }\n          if (RESERVED[key as keyof typeof RESERVED] == RESERVATIONS.func_this) {\n            return (target as any)[key].bind(target)\n          } else return (target as any)[key] // just props\n        }\n      },\n      set(target: Context<T>, key: keyof typeof RESERVED | string | symbol, value): boolean {\n        if (!(key in RESERVED)) {\n          ;(target.ctx as any)[key] = value\n          return true\n        } else if (\n          typeof key == 'string' &&\n          key in RESERVED &&\n          RESERVED[key as keyof typeof RESERVED] != RESERVATIONS.prop\n        ) {\n          return false\n        } else {\n          ;(target as any)[key] = value\n          return true\n        }\n      },\n      deleteProperty(target: Context<T>, key: string | symbol) {\n        if (!(key in RESERVED)) {\n          return delete target.ctx[key as keyof T]\n        } else {\n          return false\n        }\n      },\n      has(target: Context<T>, key: string | symbol) {\n        if (!(key in RESERVED)) {\n          if (target.__parent) {\n            return key in target.ctx || key in target.__parent\n          } else {\n            return key in target.ctx\n          }\n        } else {\n          return false\n        }\n      },\n      ownKeys(target: Context<T>) {\n        if (target.__parent) {\n          return [...Reflect.ownKeys(target.ctx), ...Reflect.ownKeys(target.__parent)]\n        } else {\n          return Reflect.ownKeys(target.ctx)\n        }\n      },\n    })\n\n    this.proxy = res\n\n    return res\n  }\n\n  /**\n   * Makes fork of current context and add it to current as a child context\n   * @api public\n   * @param {Object|Context} [config] new properties that must exists in new fork\n   * @retrun {Context}\n   */\n  fork<C extends StageObject>(ctx: C): ContextType<T & C> {\n    var child = Context.ensure<C>(ctx)\n    this.addChild<C>(child)\n    return child as ContextType<T & C>\n  }\n\n  addChild<C extends StageObject>(child: ContextType<C>): ContextType<C> {\n    if (!this.hasChild<C>(child)) {\n      child.setParent(this.proxy as unknown as ContextType<C>)\n    }\n    return child\n  }\n\n  /**\n   * Same but different as a fork. it make possible get piece of context as context;\n   * @param path String path to context object that need to be a Context instance\n   * @return {Context} | {Primitive type}\n   */\n  get(path: keyof T): any {\n    var root = get(this.ctx, path) as any\n    if (root instanceof Object) {\n      var result = root\n      if (!Context.isContext(result)) {\n        var lctx = Context.ensure(result)\n        this.addSubtree(lctx)\n        set(this, path, lctx)\n        result = lctx\n      }\n      return result\n    } else {\n      return root\n    }\n  }\n\n  addSubtree<C extends StageObject>(lctx: ContextType<C>): ContextType<C> {\n    if (!this.hasSubtree<C>(lctx)) {\n      lctx.setRoot(this.proxy)\n    }\n    return lctx\n  }\n\n  /**\n   * Return parent Context\n   * @api public\n   * @return {Context}\n   */\n  getParent() {\n    return this.__parent\n  }\n  getRoot() {\n    return this.__root\n  }\n  setParent(parent: ContextType<T>) {\n    this.__parent = parent\n  }\n  setRoot(root: ContextType<T>) {\n    this.__root = root\n  }\n  /**\n   * checks wheater or not context has specific child context\n   * it return `true` also if `ctx` is `this`;\n   * @api public\n   * @return {Boolean}\n   */\n  hasChild<C extends StageObject>(ctx: ContextType<C>): boolean {\n    if (Context.isContext(ctx) && ctx.__parent) {\n      return (\n        ctx.__parent == (this.proxy as unknown as ContextType<C>) || (this.proxy as unknown as ContextType<C>) == ctx\n      )\n    } else {\n      return false\n    }\n  }\n  hasSubtree<C extends StageObject>(ctx: ContextType<C>): boolean {\n    if (Context.isContext(ctx) && ctx.__root) {\n      return ctx.__root == (this.proxy as unknown as ContextType<C>) || (this.proxy as unknown as ContextType<C>) == ctx\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * Convert context to raw Object;\n   * @api public\n   * @param {Boolean} [clean]  `true` it need to clean object from referenced Types except Function and raw Object(js hash)\n   * @return {Object}\n   */\n  toObject<T>(): T {\n    const obj = {} as T\n    defaultsDeep(obj, this.ctx)\n    if (this.__parent) {\n      // TODO: взять весь объект по всей структуре дерева\n      defaultsDeep(obj, this.__parent.toObject())\n    }\n    return obj\n  }\n\n  /**\n   * Conterts context to JSON\n   * @api public\n   * @return {String}\n   */\n  toJSON(): string {\n    // always cleaning the object\n    return JSON.stringify(this.toObject())\n  }\n\n  /**\n   * toString\n   */\n  toString(): string {\n    return '[pipeline Context]'\n  }\n}\n","import { Possible } from './types'\n\nexport function CreateError(\n  err:\n    | string\n    | Error\n    | ComplexError\n    | null\n    | undefined\n    | (string | Error | ComplexError | null | undefined)[],\n): Possible<ComplexError> {\n  if (typeof err == 'string') {\n    return new ComplexError(new Error(err))\n  }\n  if (typeof err == 'object' && err !== null) {\n    if (Array.isArray(err)) {\n      let result: Array<Error> = []\n      err\n        .filter(e => e)\n        .forEach(ler => {\n          const res = CreateError(ler)\n          if (res) {\n            if (res.payload) {\n              result.push(...res.payload)\n            } else {\n              result.push(res)\n            }\n          }\n        })\n      if (result.length > 1) {\n        return new ComplexError(...result)\n      }\n      if (result.length === 1) {\n        return result[0] as any\n      }\n    } else if (err) {\n      if (isComplexError(err)) {\n        return err\n      } else {\n        return new ComplexError(err)\n      }\n    }\n  }\n  // throw new Error('unknown error, see console for details')\n}\n\nexport function isComplexError(inp: any): inp is ComplexError {\n  return inp.isComplex && Array.isArray(inp.payload)\n}\nexport class ComplexError extends Error {\n  payload: Array<Error>\n  isComplex: boolean\n  // to store all details of single error\n  constructor(...payload: Array<Error>) {\n    debugger\n    super()\n    this.payload = payload\n    this.isComplex = true\n  }\n}\n","import { ComplexError } from './ErrorList'\nimport { CallbackFunction, Possible, StageObject } from './types'\nimport { ContextType } from '../context'\n\nexport function empty_run<T extends StageObject>(\n  err: Possible<ComplexError>,\n  context: ContextType<T>,\n  done: CallbackFunction<T>,\n) {\n  done(err, context)\n}\n","import { JSONSchemaType } from 'ajv'\nimport { Stage, isStage } from '../stage'\nimport { CreateError, ComplexError } from './ErrorList'\n\nimport Ajv from 'ajv'\n\nimport ajvErrors from 'ajv-errors'\nimport ajvFormats from 'ajv-formats'\nimport ajvKeywords from 'ajv-keywords'\nimport { DoWhile } from '../dowhile'\nimport { Empty } from '../empty'\nimport { IfElse } from '../ifelse'\nimport { MultiWaySwitch } from '../multiwayswitch'\nimport { Parallel } from '../parallel'\nimport { Pipeline } from '../pipeline'\nimport { RetryOnError } from '../retryonerror'\nimport { Sequential } from '../sequential'\nimport { Timeout } from '../timeout'\nimport { Wrap } from '../wrap'\nimport { empty_run } from './empty_run'\nimport { ContextType } from 'src/context'\n\nexport type StageObject = Record<string | symbol | number, any>\n\nexport type CallbackFunction<T> =\n  | (() => void)\n  | ((err?: Possible<ComplexError>) => void)\n  | ((err?: Possible<ComplexError>, res?: ContextType<T>) => void)\n\nexport type CallbackExternalFunction<T> =\n  | (() => void)\n  | ((err?: Possible<Error>) => void)\n  | ((err?: Possible<Error>, res?: T) => void)\n\nexport function isCallback<T>(inp?: unknown): inp is CallbackFunction<T> {\n  if (typeof inp === 'function' && !is_async_function(inp)) {\n    return inp.length <= 2\n  } else return false\n}\n\nexport function isExternalCallback<T>(\n  inp?: unknown,\n): inp is CallbackExternalFunction<T> {\n  if (typeof inp === 'function' && !is_async_function(inp)) {\n    return inp.length <= 2\n  } else return false\n}\n\nexport function is_async_function(inp?: unknown) {\n  if (typeof inp == 'function') return inp?.constructor?.name == 'AsyncFunction'\n  else return false\n}\n\nexport function is_func1Callbacl<R, P1>(\n  inp?: Function,\n): inp is Func1Sync<R, P1> {\n  return inp?.length == 1\n}\n\n// /все типы должны быть правильно override cделаны\n\nexport type Func0Sync<R> = () => R\nexport type Func1Sync<R, P1> = (p1: P1) => R\nexport type Func2Sync<R, P1, P2> = (p1: P1, p2: P2) => R\nexport type Func3Sync<R, P1, P2, P3> = (p1: P1, p2: P2, p3: P3) => R\n\nexport type FuncSync<R, P1 = void, P2 = void, P3 = void> =\n  | Func0Sync<R>\n  | Func1Sync<R, P1>\n  | Func2Sync<R, P1, P2>\n  | Func3Sync<R, P1, P2, P3>\n\nexport type Func0Async<R> = Func0Sync<Promise<R>>\nexport type Func1Async<R, P1> = Func1Sync<Promise<R>, P1>\nexport type Func2Async<R, P1, P2> = Func2Sync<Promise<R>, P1, P2>\nexport type Func3Async<R, P1, P2, P3> = Func3Sync<Promise<R>, P1, P2, P3>\n\nexport type FuncAsync<R, P1, P2, P3> =\n  | Func0Async<R>\n  | Func1Async<R, P1>\n  | Func2Async<R, P1, P2>\n  | Func3Async<R, P1, P2, P3>\n\nexport type Func0<R> = Func0Sync<R> | Func0Async<R>\nexport type Func1<R, P1> = Func1Sync<R, P1> | Func1Async<R, P1>\nexport type Func2<R, P1, P2> = Func2Sync<R, P1, P2> | Func2Async<R, P1, P2>\nexport type Func3<R, P1, P2, P3> =\n  | Func3Sync<R, P1, P2, P3>\n  | Func3Async<R, P1, P2, P3>\n\nexport type Func<R, P1, P2, P3> =\n  | FuncSync<R, P1, P2, P3>\n  | FuncAsync<R, P1, P2, P3>\n\nexport function is_async<R, P1 = void, P2 = void, P3 = void>(\n  // inp: Func<R, P1, P2, P3>,\n  inp?: Function,\n): inp is FuncAsync<R, P1, P2, P3> {\n  return is_async_function(inp)\n}\n\nexport function is_func0<R>(inp?: Function): inp is Func0Sync<R> {\n  return inp?.length == 0\n}\n\nexport function is_func1<R, P1>(inp?: Function): inp is Func1Sync<R, P1> {\n  return inp?.length == 1\n}\n\nexport function is_func2<R, P1, P2>(\n  inp?: Function,\n): inp is Func2Sync<R, P1, P2> {\n  return inp?.length == 2\n}\n\nexport function is_func3<R, P1, P2, P3>(\n  inp?: Function,\n): inp is Func3Sync<R, P1, P2, P3> {\n  return inp?.length == 3\n}\n\nexport function is_func0_async<T>(\n  inp: Function,\n): inp is Func0Async<ContextType<T>> {\n  return is_async(inp) && is_func0(inp)\n}\n\nexport function is_func1_async<R, P1>(inp: Function): inp is Func1Async<R, P1> {\n  return is_async(inp) && is_func1(inp)\n}\n\nexport function is_func2_async<R, P1, P2>(\n  inp?: Function,\n): inp is Func2Async<R, P1, P2> {\n  return is_async(inp) && is_func2(inp)\n}\n\nexport function is_func3_async<R, P1, P2, P3>(\n  inp?: Function,\n): inp is Func3Async<R, P1, P2, P3> {\n  return is_async(inp) && is_func3(inp)\n}\n\nexport type Thanable<T> = {\n  then: Promise<T>['then']\n  catch: Promise<T>['catch']\n}\n\nexport function is_thenable<T>(inp?: any): inp is Thanable<T> {\n  return typeof inp == 'object' && 'then' in inp\n}\n\nexport type Possible<T> = T | undefined | null\n\nexport type SingleStageFunction<T extends StageObject> =\n  | Func2Async<T, Possible<ComplexError>, Possible<T>>\n  | Func3Sync<\n      void,\n      Possible<ComplexError>,\n      Possible<T>,\n      CallbackExternalFunction<T>\n    >\n\nexport function isSingleStageFunction<T extends StageObject>(\n  inp?: any,\n): inp is SingleStageFunction<T> {\n  return is_func2_async(inp) || is_func3(inp)\n}\n\nexport type RunPipelineFunction<T extends StageObject> =\n  | Func3Sync<\n      void,\n      Possible<ComplexError>,\n      ContextType<T>,\n      CallbackExternalFunction<T>\n    >\n  | Func2Sync<void, ContextType<T>, CallbackExternalFunction<T>>\n  | Func2Async<ContextType<T>, Possible<ComplexError>, ContextType<T>>\n  | Func0Sync<\n      ContextType<T> | Promise<ContextType<T>> | Thanable<ContextType<T>>\n    >\n  | Func1Async<ContextType<T>, ContextType<T>>\n  | Func1Sync<\n      ContextType<T> | Promise<ContextType<T>> | Thanable<ContextType<T>>,\n      ContextType<T>\n    >\n  | Func1Sync<void, CallbackExternalFunction<T>>\n  | Func1Sync<void, ContextType<T>>\n  | Func0Async<ContextType<T>>\n\nexport function isRunPipelineFunction<T extends StageObject>(\n  inp: any,\n): inp is RunPipelineFunction<T> {\n  return (\n    is_func0(inp) ||\n    is_func0_async(inp) ||\n    is_func1(inp) ||\n    is_func1_async(inp) ||\n    is_func2(inp) ||\n    is_func2_async(inp) ||\n    is_func3(inp)\n  )\n}\n\nexport type Rescue<T> =\n  // context is applied as this\n  | Func1Async<T, Error>\n  | Func1Sync<T | Promise<T> | Thanable<T>, Error>\n  // not applied as this\n  | Func2Async<T, Possible<ComplexError>, Possible<T>>\n  | Func2Sync<T | Promise<T> | Thanable<T>, Error, Possible<T>>\n  | Func3Sync<void, Error, Possible<T>, CallbackFunction<T>>\n\nexport function isRescue<T>(inp: any): inp is Rescue<T> {\n  return (\n    is_func1(inp) ||\n    is_func1_async(inp) ||\n    is_func2(inp) ||\n    is_func2_async(inp) ||\n    is_func3(inp)\n  )\n}\n\nexport type ValidateFunction<T> =\n  // will throw error\n  | (() => boolean)\n  | ((value: ContextType<T>) => boolean)\n  // will reject with error\n  | ((value: ContextType<T>) => Promise<boolean>)\n  | ((value: ContextType<T>) => Thanable<boolean>)\n  // will return error in callback\n  | ((\n      value: ContextType<T>,\n      callback: CallbackExternalFunction<boolean>,\n    ) => void)\n\nexport function isValidateFunction<T>(inp: any): inp is ValidateFunction<T> {\n  return is_func1(inp) || is_func1_async(inp) || is_func2(inp)\n}\n\n// validate and ensure\nexport type EnsureFunction<T> =\n  // will throw error\n  | Func1Sync<T | Promise<T> | Thanable<T>, T>\n  // will refect with error\n  | Func1Async<T, T>\n  // will return error in callback\n  | Func2Sync<void, T, CallbackFunction<T>>\n\nexport function isEnsureFunction<T>(inp: any): inp is EnsureFunction<T> {\n  return is_func1(inp) || is_func1_async(inp) || is_func2(inp)\n}\nexport interface StageConfig<T extends StageObject> {\n  run?: RunPipelineFunction<T>\n  name?: string\n  rescue?: Rescue<T>\n  schema?: JSONSchemaType<T>\n  ensure?: EnsureFunction<T>\n  validate?: ValidateFunction<T>\n  compile?<C extends StageConfig<T>>(\n    this: Stage<T, C>,\n    rebuild: boolean,\n  ): StageRun<T>\n  precompile?<C extends StageConfig<T>>(this: C): void\n}\n\nexport interface PipelineConfig<T extends StageObject> extends StageConfig<T> {\n  stages: Array<AnyStage<T, T> | RunPipelineFunction<T>>\n}\n\nexport interface ParallelConfig<T extends StageObject, R extends StageObject>\n  extends StageConfig<T> {\n  stage: AnyStage<R> | RunPipelineFunction<R>\n  split?: Func1Sync<Array<ContextType<R>>, ContextType<T>>\n  combine?: Func2Sync<\n    ContextType<T> | void,\n    ContextType<T>,\n    Array<ContextType<R>>\n  >\n}\n\nexport function isStageRun<T extends StageObject>(\n  inp: Function,\n): inp is StageRun<T> {\n  return inp?.length == 3\n}\n\nexport type StageRun<T extends StageObject> = (\n  err: Possible<ComplexError>,\n  context: ContextType<T>,\n  callback: CallbackFunction<T>,\n) => void\n\nexport type InternalStageRun<T extends StageObject> = (\n  err: Possible<ComplexError>,\n  context: ContextType<T>,\n  callback: CallbackFunction<T>,\n) => void\n\nexport type AllowedStage<\n  T extends StageObject,\n  R extends StageObject,\n  C extends StageConfig<T>,\n> = string | C | RunPipelineFunction<T> | AnyStage<T>\n\nexport function isAllowedStage<\n  T extends StageObject,\n  R extends StageObject,\n  C extends StageConfig<T>,\n>(inp: any): inp is AllowedStage<T, R, C> {\n  return (\n    isRunPipelineFunction(inp) ||\n    isAnyStage(inp) ||\n    typeof inp == 'object' ||\n    typeof inp == 'string'\n  )\n}\n\nexport function getStageConfig<\n  T extends StageObject,\n  R extends StageObject,\n  C extends StageConfig<T>,\n>(config: AllowedStage<T, R, C>): C | AnyStage<T, R> {\n  let result: C = {} as C\n  if (typeof config == 'string') {\n    result.name = config\n  } else if (isAnyStage<T, R>(config)) {\n    return config\n  } else if (isRunPipelineFunction<T>(config)) {\n    result.run = config\n    result.name = getNameFrom<T, C>(result)\n  } else {\n    if (config.name) {\n      result.name = config.name\n    }\n    if (isRescue<T>(config.rescue)) {\n      result.rescue = config.rescue\n    }\n    if (isRunPipelineFunction<T>(config.run)) {\n      result.run = config.run\n    }\n    if (config.validate && config.schema) {\n      throw CreateError('use only one `validate` or `schema`')\n    }\n    if (config.ensure && config.schema) {\n      throw CreateError('use only one `ensure` or `schema`')\n    }\n    if (config.ensure && config.validate) {\n      throw CreateError('use only one `ensure` or `validate`')\n    }\n    if (isValidateFunction<T>(config.validate)) {\n      result.validate = config.validate\n    }\n    if (isEnsureFunction<T>(config.ensure)) {\n      result.ensure = config.ensure\n    }\n    if (config.compile) {\n      result.compile = config.compile\n    }\n    if (config.precompile) {\n      result.precompile = config.precompile\n    }\n    if (config.schema) {\n      result.schema = config.schema as JSONSchemaType<T>\n      const ajv = new Ajv({ allErrors: true })\n      ajvFormats(ajv)\n      ajvErrors(ajv, { singleError: true })\n      ajvKeywords(ajv)\n      const validate = ajv.compile(result.schema)\n      result.validate = ((ctx: T): boolean => {\n        if (!validate(ctx) && validate.errors) {\n          throw CreateError(ajv.errorsText(validate.errors))\n        } else return true\n      }) as ValidateFunction<T>\n    }\n    if (!config.name) {\n      result.name = getNameFrom<T, C>(config)\n    }\n  }\n  return result\n}\n\nexport function getNameFrom<T extends StageObject, C extends StageConfig<T>>(\n  config: C,\n): string {\n  let result: string = ''\n  if (!config.name && config.run) {\n    var match = config.run.toString().match(/function\\s*(\\w+)\\s*\\(/)\n    if (match && match[1]) {\n      result = match[1]\n    } else {\n      result = config.run.toString()\n    }\n  } else {\n    result = config.name ?? ''\n  }\n  return result\n}\n\nexport type AllowedPipeline<T extends StageObject, R extends StageObject> =\n  | AllowedStage<T, R, PipelineConfig<T>>\n  | Array<RunPipelineFunction<T> | AnyStage<T>>\n\nexport function getPipelinConfig<T extends StageObject, R extends StageObject>(\n  config: AllowedPipeline<T, R>,\n): PipelineConfig<T> {\n  if (Array.isArray(config)) {\n    return {\n      stages: config.map((item): AnyStage<T> | RunPipelineFunction<T> => {\n        if (isRunPipelineFunction(item)) {\n          return item as RunPipelineFunction<T>\n        } else if (isAnyStage<T, R>(item)) {\n          return item as AnyStage<T>\n        } else {\n          throw CreateError('not suitable type for array in pipeline')\n        }\n      }),\n    }\n  } else {\n    const res: PipelineConfig<T> | AnyStage<T, R> = getStageConfig<\n      T,\n      R,\n      PipelineConfig<T>\n    >(config)\n    if (isAnyStage<T, R>(res)) {\n      return { stages: [res] } as PipelineConfig<T>\n    } else if (typeof config == 'object' && !isAnyStage<T, R>(config)) {\n      if (config.run && config.stages?.length > 0) {\n        throw CreateError(\" don't use run and stage both \")\n      }\n      if (config.run) {\n        res.stages = [config.run]\n      }\n      if (config.stages) {\n        res.stages = config.stages\n      }\n    } else if (typeof config == 'function' && res.run) {\n      res.stages = [res.run]\n      delete res.run\n    }\n    if (!res.stages) res.stages = []\n    return res\n  }\n}\n\nexport function getParallelConfig<T extends StageObject, R extends StageObject>(\n  config: AllowedStage<T, R, ParallelConfig<T, R>>,\n): ParallelConfig<T, R> {\n  const res = getStageConfig<R, R, ParallelConfig<T, R>>(config)\n  if (isAnyStage<T, R>(res) || isRunPipelineFunction<R>(res)) {\n    return { stage: res } as ParallelConfig<T, R>\n  } else if (typeof config == 'object' && !isAnyStage<T, R>(config)) {\n    const r = res as ParallelConfig<T, R>\n    if (config.run && config.stage) {\n      throw CreateError(\"don't use run and stage both\")\n    }\n    if (config.split) {\n      r.split = config.split\n    }\n    if (config.combine) {\n      r.combine = config.combine\n    }\n    if (config.stage) {\n      r.stage = config.stage\n    }\n    if (config.run) {\n      r.stage = config.run\n    }\n  } else if (typeof config == 'function' && (res as StageConfig<T>).run) {\n    ;(res as ParallelConfig<T, R>).stage = (res as StageConfig<T>)\n      .run as RunPipelineFunction<T>\n    delete (res as StageConfig<T>).run\n  }\n  return res as ParallelConfig<T, R>\n}\n\nexport function getEmptyConfig<T extends StageObject, R extends StageObject>(\n  config: AllowedStage<T, R, StageConfig<T>>,\n): AnyStage<T> | StageConfig<T> {\n  const res = getStageConfig(config)\n\n  if (isAnyStage<T, R>(res)) {\n    return res\n  } else {\n    res.run = empty_run as RunPipelineFunction<T>\n  }\n\n  return res\n}\n\nexport interface WrapConfig<T extends StageObject, R extends StageObject>\n  extends StageConfig<T> {\n  stage: AnyStage<T> | RunPipelineFunction<T>\n  prepare: (ctx: ContextType<T>) => ContextType<R>\n  finalize?: (ctx: ContextType<T>, retCtx: ContextType<R>) => ContextType<T>\n}\n\nexport function getWrapConfig<\n  T extends StageObject,\n  R extends StageObject,\n  C extends WrapConfig<T, R>,\n>(config: AllowedStage<T, R, C>): C {\n  const res = getStageConfig<T, R, C>(config)\n  if (isAnyStage<T, R>(res)) {\n    return { stage: res } as C\n  } else if (typeof config == 'object' && !isAnyStage<T, R>(config)) {\n    if (config.run && config.stage) {\n      throw CreateError(\"don't use run and stage both\")\n    }\n    if (config.run) {\n      res.stage = config.run as RunPipelineFunction<any>\n    }\n    if (config.stage) {\n      res.stage = config.stage\n    }\n    if (config.finalize) {\n      res.finalize = config.finalize\n    }\n    if (config.prepare) {\n      res.prepare = config.prepare\n    }\n    res.prepare = config.prepare\n  }\n  return res\n}\n\nexport interface TimeoutConfig<T extends StageObject> extends StageConfig<T> {\n  timeout?: number | Func1Sync<number, Possible<T>>\n  stage?: AnyStage<T> | RunPipelineFunction<T>\n  overdue?: AnyStage<T> | RunPipelineFunction<T>\n}\n\nexport function getTimeoutConfig<T extends StageObject>(\n  config: AllowedStage<T, T, TimeoutConfig<T>>,\n): TimeoutConfig<T> {\n  const res = getStageConfig<T, T, TimeoutConfig<T>>(config)\n  if (isAnyStage<T, T>(res)) {\n    return { stage: res } as TimeoutConfig<T>\n  } else if (typeof config == 'object' && !isAnyStage<T, T>(config)) {\n    if (config.run && config.stage) {\n      throw CreateError(\"don't use run and stage both\")\n    }\n    if (config.run) {\n      res.stage = config.run\n    }\n    if (config.stage) {\n      res.stage = config.stage\n    }\n    res.timeout = config.timeout\n    res.overdue = config.overdue\n  } else if (typeof config == 'function' && res.run) {\n    res.stage = res.run\n    delete res.run\n  }\n  return res\n}\n\nexport interface IfElseConfig<T extends StageObject> extends StageConfig<T> {\n  condition?: boolean | ValidateFunction<T>\n  success?: AnyStage<T> | RunPipelineFunction<T>\n  failed?: AnyStage<T> | RunPipelineFunction<T>\n}\n\nexport function getIfElseConfig<\n  T extends StageObject,\n  C extends IfElseConfig<T>,\n>(config: AllowedStage<T, T, C>): C {\n  const res = getStageConfig<T, T, C>(config)\n  if (isAnyStage<T, C>(res)) {\n    return { success: res } as C\n  } else if (typeof config == 'object' && !isAnyStage<T, C>(config)) {\n    if (config.run && config.success) {\n      throw CreateError(\"don't use run and stage both\")\n    }\n    if (config.run) {\n      res.success = config.run\n    }\n    if (config.success) {\n      res.success = config.success\n    }\n    if (config.condition) {\n      res.condition = config.condition\n    } else {\n      res.condition = true\n    }\n    if (config.failed) {\n      res.failed = config.failed\n    } else {\n      res.failed = empty_run as RunPipelineFunction<T>\n    }\n  } else if (typeof config == 'function' && res.run) {\n    res.success = res.run\n    res.failed = empty_run as RunPipelineFunction<T>\n    res.condition = true\n    delete res.run\n  } else {\n    res.success = empty_run as RunPipelineFunction<T>\n  }\n  return res\n}\n\nexport type AnyStage<T extends StageObject, R extends StageObject = T> =\n  | Stage<T, StageConfig<T>>\n  | DoWhile<T, R>\n  | Empty<T>\n  | IfElse<T>\n  | MultiWaySwitch<T, R>\n  | Parallel<T, R>\n  | Pipeline<T>\n  | RetryOnError<T>\n  | Sequential<T, R>\n  | Timeout<T>\n  | Wrap<T, R>\n\nexport function isAnyStage<T extends StageObject, R extends StageObject = T>(\n  obj: any,\n): obj is AnyStage<T, R> {\n  return isStage(obj)\n}\n","import {\n  is_func2_async,\n  is_func3,\n  is_func3_async,\n  RunPipelineFunction,\n  StageObject,\n} from './types'\n\nexport function can_fix_error<T extends StageObject>({\n  run,\n}: {\n  run: RunPipelineFunction<T>\n}) {\n  return is_func2_async(run) || (is_func3(run) && !is_func3_async(run))\n}\n","export const ERROR = {\n  signature: 'unacceptable run method signature',\n  invalid_context: 'context is invalid',\n}\n","import { ComplexError, CreateError, isComplexError } from './ErrorList'\nimport { CallbackFunction } from './types'\n\nexport function process_error<T>(err: unknown, done: CallbackFunction<T>) {\n  if (isComplexError(err)) {\n    done(err)\n  } else if (err instanceof Error) {\n    done(new ComplexError(err))\n  } else if (typeof err == 'string') {\n    done(CreateError(err))\n  } else {\n    done(CreateError(String(err)))\n  }\n}\n","import { ComplexError, CreateError } from './ErrorList'\nimport { CallbackFunction, Possible } from './types'\nimport { ContextType } from '../context'\n\nexport function run_callback_once<T>(\n  wrapee: CallbackFunction<T>,\n): CallbackFunction<T> {\n  let done_call = 0\n  const c = function (err: Possible<ComplexError>, ctx: ContextType<T>) {\n    if (done_call == 0) {\n      done_call += 1\n      wrapee(err, ctx)\n    } else if (err) {\n      throw err\n    } else {\n      throw CreateError([err, 'callback called more than once'])\n    }\n  } as CallbackFunction<T>\n  return c\n}\n","import { ComplexError, CreateError } from './ErrorList'\nimport { ERROR } from './errors'\nimport { process_error } from './process_error'\nimport { run_callback_once } from './run_callback_once'\nimport {\n  CallbackFunction,\n  Func1Sync,\n  Func2Sync,\n  is_func2_async,\n  is_func3,\n  is_func3_async,\n  is_thenable,\n  RunPipelineFunction,\n  StageObject,\n  Thanable,\n} from './types'\nimport {\n  is_func0,\n  is_func0_async,\n  is_func1,\n  is_func1_async,\n  is_func2,\n} from './types'\nimport { Possible } from './types'\nimport { ContextType } from '../context'\n\n// может не являться async funciton но может вернуть промис, тогда тоже должен отработать как промис\n\nexport function execute_callback<T extends StageObject>(\n  err: Possible<ComplexError>,\n  run: RunPipelineFunction<T>,\n  context: ContextType<T>,\n  _done: CallbackFunction<T>,\n) {\n  const done = run_callback_once(_done)\n  switch (run.length) {\n    // this is the context of the run function\n    case 0:\n      if (is_func0_async<ContextType<T>>(run)) {\n        try {\n          const res = run.call(context)\n          res\n            .then(res => done(undefined, res ?? context))\n            .catch(err => done(err))\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else if (is_func0<ContextType<T>>(run)) {\n        try {\n          const res = run.apply(context)\n          if (res instanceof Promise) {\n            res\n              .then(_ => done(undefined, res ?? context))\n              .catch(err => done(err))\n          } else if (is_thenable(res)) {\n            res\n              .then(_ => done(undefined, res ?? context))\n              .catch(err => done(err))\n          } else {\n            done(undefined, res ?? context)\n          }\n        } catch (err) {\n          process_error(err, done)\n        }\n      }\n      break\n    case 1:\n      if (is_func1_async<ContextType<T>, ContextType<T>>(run)) {\n        try {\n          run(context)\n            .then(ctx => done(undefined, ctx))\n            .catch(err => done(err))\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else if (is_func1(run)) {\n        try {\n          const res = (\n            run as Func1Sync<\n              | ContextType<T>\n              | Promise<ContextType<T>>\n              | Thanable<ContextType<T>>,\n              T\n            >\n          )(context)\n          if (res instanceof Promise) {\n            res.then(r => done(undefined, r ?? context)).catch(err => done(err))\n          } else if (is_thenable(res)) {\n            res.then(r => done(undefined, r ?? context)).catch(err => done(err))\n          } else {\n            done(undefined, res)\n          }\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else {\n        done(CreateError(ERROR.signature))\n      }\n      break\n    case 2:\n      if (\n        is_func2_async<ContextType<T>, Possible<ComplexError>, ContextType<T>>(\n          run,\n        )\n      ) {\n        try {\n          run(err, context)\n            .then(ctx => done(undefined, ctx))\n            .catch(err => done(err))\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else if (is_func2(run)) {\n        try {\n          ;(run as Func2Sync<void, T, CallbackFunction<T>>)(context, done)\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else {\n        done(CreateError(ERROR.signature))\n      }\n      break\n    case 3:\n      if (\n        is_func3<void, Possible<ComplexError>, T, CallbackFunction<T>>(run) &&\n        !is_func3_async(run)\n      ) {\n        try {\n          run(err, context, done)\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else {\n        done(CreateError(ERROR.signature))\n      }\n      break\n    default:\n      done(CreateError(ERROR.signature))\n  }\n}\n","import { ComplexError, CreateError } from './ErrorList'\nimport { ERROR } from './errors'\nimport { process_error } from './process_error'\nimport { run_callback_once } from './run_callback_once'\nimport {\n  CallbackFunction,\n  Func2Sync,\n  is_func2_async,\n  is_func3,\n  is_func3_async,\n  is_thenable,\n  Possible,\n  RunPipelineFunction,\n  StageObject,\n  StageRun,\n  Thanable,\n} from './types'\nimport {\n  is_func0,\n  is_func0_async,\n  is_func1,\n  is_func1_async,\n  is_func2,\n} from './types'\nimport { Func3Sync } from './types'\nimport { ContextType } from '../context'\n\n// может не являться async funciton но может вернуть промис, тогда тоже должен отработать как промис\n\nexport function execute_custom_run<T extends StageObject>(\n  run: RunPipelineFunction<T>,\n): StageRun<T> {\n  return function (\n    this: any,\n    err: Possible<ComplexError>,\n    context: ContextType<T>,\n    _done: CallbackFunction<T>,\n  ) {\n    const done = run_callback_once(_done)\n    switch (run.length) {\n      // this is the context of the run function\n      case 0:\n        if (is_func0_async<ContextType<T>>(run)) {\n          try {\n            const res = run.call(context)\n            res.then(r => done(undefined, r)).catch(err => done(err))\n          } catch (err) {\n            process_error(err, done)\n          }\n        } else if (is_func0<ContextType<T>>(run)) {\n          try {\n            const res = run.apply(context)\n            if (res instanceof Promise) {\n              res.then(r => done(undefined, r)).catch(err => done(err))\n            } else if (is_thenable<ContextType<T>>(res)) {\n              res.then(r => done(undefined, r)).catch(err => done(err))\n            } else {\n              done(undefined, res)\n            }\n          } catch (err) {\n            process_error(err, done)\n          }\n        }\n        break\n      case 1:\n        if (is_func1_async<ContextType<T>, ContextType<T>>(run)) {\n          try {\n            run(context)\n              .then(ctx => done(undefined, ctx))\n              .catch(err => done(err))\n          } catch (err) {\n            process_error(err, done)\n          }\n        } else if (\n          is_func1<\n            ContextType<T> | Promise<ContextType<T>> | Thanable<ContextType<T>>,\n            ContextType<T>\n          >(run)\n        ) {\n          try {\n            const res = run.call(this, context)\n            if (res instanceof Promise) {\n              res.then(r => done(undefined, r)).catch(err => done(err))\n            } else if (is_thenable<ContextType<T>>(res)) {\n              res.then(r => done(undefined, r)).catch(err => done(err))\n            } else {\n              done(undefined, res)\n            }\n          } catch (err) {\n            process_error(err, done)\n          }\n        } else {\n          done(CreateError(ERROR.signature))\n        }\n        break\n      case 2:\n        if (\n          is_func2_async<\n            ContextType<T>,\n            Possible<ComplexError>,\n            ContextType<T>\n          >(run)\n        ) {\n          try {\n            run\n              .call(this, err, context)\n              .then(ctx => done(undefined, ctx))\n              .catch(err => done(err))\n          } catch (err) {\n            process_error(err, done)\n          }\n        } else if (is_func2(run)) {\n          try {\n            ;(run as Func2Sync<void, Possible<T>, CallbackFunction<T>>).call(\n              this,\n              context,\n              done,\n            )\n          } catch (err) {\n            process_error(err, done)\n          }\n        } else {\n          done(CreateError(ERROR.signature))\n        }\n        break\n      case 3:\n        if (is_func3(run) && !is_func3_async(run)) {\n          try {\n            ;(\n              run as Func3Sync<void, Error, Possible<T>, CallbackFunction<T>>\n            ).call(this, err as Error, context, done)\n          } catch (err) {\n            process_error(err, done)\n          }\n        } else {\n          done(CreateError(ERROR.signature))\n        }\n        break\n      default:\n        done(CreateError(ERROR.signature))\n    }\n  }\n}\n","import { CreateError, ComplexError } from './ErrorList'\nimport { ERROR } from './errors'\nimport { process_error } from './process_error'\nimport {\n  CallbackFunction,\n  EnsureFunction,\n  Func1Sync,\n  is_thenable,\n  Thanable,\n} from './types'\nimport { is_func1, is_func1_async, is_func2 } from './types'\nimport { Func1Async } from './types'\nimport { ContextType } from '../context'\n\nexport function execute_ensure<T>(\n  ensure: EnsureFunction<T>,\n  context: ContextType<T>,\n  done: CallbackFunction<T>,\n) {\n  switch (ensure.length) {\n    case 1:\n      if (is_func1_async(ensure)) {\n        try {\n          ;(ensure as Func1Async<ContextType<T>, ContextType<T>>)(context)\n            .then(res => done(undefined, res))\n            .catch(err => done(err))\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else if (is_func1(ensure)) {\n        try {\n          const res = (\n            ensure as Func1Sync<\n              | ContextType<T>\n              | Promise<ContextType<T>>\n              | Thanable<ContextType<T>>,\n              T\n            >\n          )(context)\n          if (res instanceof Promise) {\n            res.then(res => done(undefined, res)).catch(err => done(err))\n          } else if (is_thenable(res)) {\n            res.then(res => done(undefined, res)).catch(err => done(err))\n          } else {\n            done(undefined, res)\n          }\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else {\n        done(CreateError(ERROR.signature))\n      }\n      break\n    case 2:\n      if (is_func2(ensure)) {\n        try {\n          ensure(context, (err: ComplexError, ctx: ContextType<T>) => {\n            done(err, ctx)\n          })\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else {\n        done(CreateError(ERROR.signature))\n      }\n      break\n    default:\n      done(CreateError(ERROR.signature))\n  }\n}\n","import { IContextProxy } from '../context'\nimport { ComplexError, CreateError } from './ErrorList'\nimport { ERROR } from './errors'\nimport { process_error } from './process_error'\nimport {\n  is_func2_async,\n  is_func3,\n  is_func3_async,\n  is_thenable,\n  Possible,\n  Rescue,\n} from './types'\nimport { is_func1, is_func1_async, is_func2 } from './types'\n\nexport function execute_rescue<T>(\n  rescue: Rescue<T>,\n  err: Error,\n  context: IContextProxy<T>,\n  done: (err?: Possible<ComplexError>) => void,\n) {\n  switch (rescue.length) {\n    case 1:\n      if (is_func1_async(rescue)) {\n        try {\n          rescue(err)\n            .then(_ => done(undefined))\n            .catch(err => done(err))\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else if (is_func1(rescue)) {\n        try {\n          const res = rescue(err)\n          if (res instanceof Promise) {\n            res.then(_ => done()).catch(err => done(err))\n          } else if (is_thenable(res)) {\n            res.then(_ => done()).catch(err => done(err))\n          } else {\n            done()\n          }\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else {\n        done(CreateError(ERROR.signature))\n      }\n      break\n    case 2:\n      if (is_func2_async(rescue)) {\n        try {\n          rescue(err, context)\n            .then(_ => done())\n            .catch(err => done(err))\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else if (is_func2(rescue)) {\n        try {\n          const res = rescue(err, context)\n          if (res instanceof Promise) {\n            res.then(_ => done()).catch(err => done(err))\n          } else if (is_thenable(res)) {\n            res.then(_ => done()).catch(err => done(err))\n          } else {\n            done()\n          }\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else {\n        done(CreateError(ERROR.signature))\n      }\n      break\n    case 3:\n      if (is_func3(rescue) && !is_func3_async(rescue)) {\n        try {\n          rescue(err, context, done)\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else {\n        done(CreateError(ERROR.signature))\n      }\n      break\n    default:\n      done(CreateError(ERROR.signature))\n  }\n}\n","import { CreateError } from './ErrorList'\nimport { ERROR } from './errors'\nimport { process_error } from './process_error'\nimport {\n  CallbackExternalFunction,\n  Func1Sync,\n  is_thenable,\n  Possible,\n  Thanable,\n  ValidateFunction,\n} from './types'\nimport { is_func1, is_func1_async, is_func2 } from './types'\nimport { Func1Async } from './types'\nimport { ContextType } from '../context'\n\nexport function execute_validate<T>(\n  validate: ValidateFunction<T>,\n  context: ContextType<T>,\n  done: CallbackExternalFunction<boolean>,\n) {\n  switch (validate.length) {\n    case 1:\n      if (is_func1_async(validate)) {\n        try {\n          ;(validate as Func1Async<boolean, ContextType<T>>)(context)\n            .then(res => done(undefined, res))\n            .catch(err => done(err))\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else if (is_func1(validate)) {\n        try {\n          const res = (\n            validate as Func1Sync<\n              boolean | Promise<boolean> | Thanable<boolean>,\n              Possible<T>\n            >\n          )(context)\n          if (res instanceof Promise) {\n            res.then(res => done(undefined, res)).catch(err => done(err))\n          } else if (is_thenable(res)) {\n            res.then(res => done(undefined, res)).catch(err => done(err))\n          } else if (typeof res == 'boolean') {\n            if (res) {\n              done(undefined, res)\n            } else {\n              done(CreateError(ERROR.invalid_context))\n            }\n          } else {\n            done(res)\n          }\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else {\n        done(CreateError(ERROR.signature))\n      }\n      break\n    case 2:\n      if (is_func2(validate)) {\n        try {\n          validate(context, (err: Possible<Error>, res: boolean) => {\n            if (err) done(CreateError(err), res)\n            else done(err, res)\n          })\n        } catch (err) {\n          process_error(err, done)\n        }\n      } else {\n        done(CreateError(ERROR.signature))\n      }\n      break\n    default:\n      done(CreateError(ERROR.signature))\n  }\n}\n","import { ComplexError, CreateError } from './utils/ErrorList'\nimport {\n  AllowedStage,\n  CallbackExternalFunction,\n  CallbackFunction,\n  EnsureFunction,\n  getStageConfig,\n  InternalStageRun,\n  Possible,\n  RunPipelineFunction,\n  StageConfig,\n  StageObject,\n  StageRun,\n  ValidateFunction,\n} from './utils/types'\n\nimport { Context, ContextType, OriginalObject } from './context'\nimport { can_fix_error } from './utils/can_fix_error'\nimport { execute_callback } from './utils/execute_callback'\nimport { execute_custom_run } from './utils/execute_custom_run'\nimport { execute_ensure } from './utils/execute_ensure'\nimport { execute_rescue } from './utils/execute_rescue'\nimport { execute_validate } from './utils/execute_validate'\nimport { isStageRun, Rescue, AnyStage, isAnyStage } from './utils/types'\nexport const StageSymbol = Symbol('stage')\n// make possibility to context be immutable for debug purposes\nexport function isStage<\n  T extends StageObject,\n  C extends StageConfig<T> = StageConfig<T>,\n>(obj: any): obj is Stage<T, C> {\n  return !!obj[StageSymbol]\n}\nexport class Stage<\n  T extends StageObject,\n  C extends StageConfig<T> = StageConfig<T>,\n> {\n  public get config(): C {\n    return this._config\n  }\n  [StageSymbol]: boolean\n  protected _config!: C\n  constructor()\n  constructor(name: string)\n  constructor(config: C)\n  constructor(runFn: RunPipelineFunction<T>)\n  constructor(stage: AnyStage<T>)\n  constructor(config?: AllowedStage<T, T, C>) {\n    this[StageSymbol] = true\n    if (config) {\n      let res = getStageConfig(config)\n      if (isAnyStage<T, C>(res)) {\n        return res as Stage<T, C>\n      } else {\n        this._config = res as C\n      }\n    } else {\n      this._config = {} as C\n    }\n  }\n\n  public get reportName() {\n    return `STG:${this._config.name ? this._config.name : ''}`\n  }\n\n  public get name() {\n    return this._config.name ?? ''\n  }\n\n  protected runStageMethod(\n    err_: Possible<ComplexError>,\n    err: Possible<ComplexError>,\n    ctx: ContextType<T>,\n    context: ContextType<T>,\n    stageToRun: InternalStageRun<T>,\n    callback: CallbackFunction<T>,\n  ) {\n    if (err || err_) {\n      if (this.config.run && !can_fix_error({ run: this.config.run })) {\n        this.rescue<T>(\n          CreateError([err, err_]),\n          ctx ?? context,\n          callback,\n          rescuedContext => {\n            // ошибка обработана все хорошо, продолжаем\n            stageToRun(undefined, rescuedContext, callback)\n          },\n        )\n      } else {\n        // обработка ошибок может происходить внутри функции\n        stageToRun(CreateError([err, err_]), ctx ?? context, callback)\n      }\n    } else {\n      stageToRun(undefined, ctx ?? context, callback)\n    }\n  }\n\n  // может быть вызван как Promise\n  // сделать все дубликаты и проверки методов для работы с промисами\n  public execute(context: T): Promise<T>\n  public execute(context: ContextType<T>): Promise<T>\n  public execute(context: T, callback: CallbackExternalFunction<T>): void\n  public execute(\n    context: ContextType<T>,\n    callback: CallbackExternalFunction<T>,\n  ): void\n  public execute(\n    err: Possible<ComplexError>,\n    context: T,\n    callback: CallbackExternalFunction<T>,\n  ): void\n  public execute(\n    _err?: Possible<ComplexError | T>,\n    _context?: T | CallbackExternalFunction<T>,\n    _callback?: Possible<CallbackExternalFunction<T>>,\n  ): void | Promise<T> {\n    // discover arguments\n    let err: Possible<ComplexError>,\n      not_ensured_context: T | ContextType<T>,\n      __callback: Possible<CallbackExternalFunction<T>>\n\n    if (arguments.length == 1) {\n      not_ensured_context = _err as T | ContextType<T>\n      // promise\n    } else if (arguments.length == 2) {\n      if (typeof _context == 'function') {\n        // callback\n        not_ensured_context = _err as T | ContextType<T>\n        err = undefined\n        __callback = _context as CallbackFunction<T>\n      } else {\n        // promise\n        err = _err as ComplexError\n        not_ensured_context = _context as T | ContextType<T>\n      }\n    } else {\n      // callback\n      err = _err as ComplexError\n      not_ensured_context = _context as T | ContextType<T>\n      __callback = _callback as CallbackFunction<T>\n    }\n\n    if (!this.run) {\n      this.run = this.compile()\n    } else if (!this.config?.run) {\n      // legacy run\n      if (!isStageRun(this.run)) {\n        var legacy = this.run as RunPipelineFunction<T>\n        this.run = execute_custom_run(legacy)\n      }\n    }\n\n    const stageToRun = this.run.bind(this)\n\n    const input_is_context = Context.isContext(not_ensured_context)\n    let context = Context.ensure<T>(not_ensured_context)\n    if (input_is_context) {\n      ;(context as unknown as Context<T>)[OriginalObject] = true\n    }\n    if (!__callback) {\n      return new Promise((res, rej) => {\n        this.execute(err, context, ((err: Possible<ComplexError>, ctx: T) => {\n          if (err) rej(err)\n          else {\n            if (input_is_context) {\n              res(ctx)\n            } else {\n              if (Context.isContext(ctx)) {\n                res(ctx.original)\n              } else {\n                res(ctx)\n              }\n            }\n          }\n        }) as CallbackFunction<T>)\n      })\n    } else {\n      const back: typeof __callback = (err, _ctx) => {\n        if (input_is_context) {\n          __callback?.(err, _ctx)\n        } else {\n          if (Context.isContext(_ctx)) {\n            __callback?.(err, _ctx.original)\n          } else {\n            __callback?.(\n              CreateError([err, new Error('context is always context object')]),\n              _ctx,\n            )\n          }\n        }\n      }\n      process.nextTick(() => {\n        const sucess = (ret: T) => back(undefined, ret ?? context)\n        const fail = (err: Possible<ComplexError>) => back(err, context)\n        const callback = ((\n          err: Possible<ComplexError>,\n          _ctx: ContextType<T>,\n        ) => {\n          if (err) {\n            this.rescue(err, _ctx, fail, sucess)\n          } else {\n            back(err, _ctx)\n          }\n        }) as CallbackFunction<T>\n\n        if (\n          err &&\n          this._config.run &&\n          !can_fix_error({ run: this._config.run })\n        ) {\n          this.rescue(err, context, fail, sucess)\n        } else {\n          if (this.config.ensure) {\n            this.ensure(this.config.ensure, context, ((\n              err_: Possible<ComplexError>,\n              ctx: ContextType<T>,\n            ) => {\n              this.runStageMethod(err, err_, ctx, context, stageToRun, callback)\n            }) as CallbackFunction<T>)\n          } else if (this._config.validate) {\n            this.validate(this._config.validate, context, ((\n              err_: Possible<ComplexError>,\n              ctx: ContextType<T>,\n            ) => {\n              this.runStageMethod(err, err_, ctx, context, stageToRun, callback)\n            }) as CallbackFunction<T>)\n          } else {\n            stageToRun(undefined, context, callback)\n          }\n        }\n      })\n    }\n  }\n\n  protected stage(\n    err: Possible<ComplexError>,\n    context: ContextType<T>,\n    callback: CallbackFunction<T>,\n  ) {\n    const back = callback\n    const sucess = (ret: ContextType<T>) => back(undefined, ret ?? context)\n    const fail = (err: Possible<ComplexError>) => back(err, context)\n    if (this._config.run) {\n      if (context) {\n        execute_callback(err, this._config.run, context, ((\n          err: Possible<ComplexError>,\n          ctx: ContextType<T>,\n        ) => {\n          if (err) {\n            this.rescue(err, ctx ?? context, fail, sucess)\n          } else {\n            callback(undefined, ctx ?? context)\n          }\n        }) as CallbackFunction<T>)\n      } else {\n        // возвращаем управление\n        callback(null, context)\n      }\n    } else {\n      const retErr: Array<any> = [\n        this.reportName + ' reports: run is not a function',\n      ]\n      if (err) retErr.push(err)\n      this.rescue(CreateError(retErr), context, fail, sucess)\n    }\n  }\n\n  public compile(rebuild: boolean = false): StageRun<T> {\n    let res: StageRun<T>\n    if (this.config.precompile) {\n      this.config.precompile()\n    }\n    if (this._config.compile) {\n      res = this._config.compile.call(this, rebuild)\n    } else if (!this.run || rebuild) {\n      res = this.stage\n    } else {\n      if (isStageRun<T>(this.run)) {\n        res = this.run\n      } else {\n        res = execute_custom_run(this.run as RunPipelineFunction<T>)\n      }\n    }\n    return res\n  }\n  // to be overridden by compile\n  protected run?: InternalStageRun<T>\n\n  // объединение ошибок сделать\n  // посмотреть что нужно сделать чтобы вызвать ошибку правильно!!!\n  // в начале выполнения важен правильный callback, возможно без контекста\n  // в конце важен и контекст ошибки? или не важен\n  protected rescue<E>(\n    _err: Possible<Error | string>,\n    context: ContextType<T>,\n    fail: (err: Possible<ComplexError>) => void,\n    success: (ctx: ContextType<T>) => void,\n  ) {\n    let err: Possible<ComplexError>\n\n    if (_err) {\n      if (!(_err instanceof Error)) {\n        err = CreateError(_err)\n      } else {\n        err = CreateError(_err)\n      }\n    } else {\n      err = null\n    }\n\n    if (err && this._config.rescue) {\n      execute_rescue<E>(\n        this._config.rescue as Rescue<E>,\n        err,\n        context,\n        (_err: Possible<ComplexError>) => {\n          // здесь может быть исправлена ошибка, и контекст передается дальше на выполнение\n          if (_err) {\n            fail(_err)\n          } else {\n            success(context)\n          }\n        },\n      )\n    } else {\n      // отправить ошибку дальше\n      // окончателная ошибка и выходим из выполнения\n      if (err) {\n        fail(err)\n      } else {\n        success(context)\n      }\n    }\n  }\n\n  public toString() {\n    return '[pipeline Stage]'\n  }\n\n  protected validate(\n    validate: ValidateFunction<T>,\n    context: ContextType<T>,\n    callback: CallbackFunction<T>,\n  ) {\n    execute_validate(validate, context, ((\n      err: Possible<ComplexError>,\n      result: boolean,\n    ) => {\n      if (err) {\n        callback(err, context)\n      } else {\n        if (result) {\n          if ('boolean' === typeof result) {\n            callback(undefined, context)\n          } else if (Array.isArray(result)) {\n            callback(CreateError(result))\n          }\n        } else {\n          callback(CreateError(this.reportName + ' reports: T is invalid'))\n        }\n      }\n    }) as CallbackFunction<boolean>)\n  }\n  protected ensure(\n    ensure: EnsureFunction<T>,\n    context: ContextType<T>,\n    callback: CallbackFunction<T>,\n  ) {\n    execute_ensure(ensure, context, ((\n      err: Possible<ComplexError>,\n      result: ContextType<T>,\n    ) => {\n      callback(err, result ?? context)\n    }) as CallbackFunction<T>)\n  }\n}\n\nexport type EnsureParams<T> = {\n  context: ContextType<T>\n  callback: CallbackFunction<T> | undefined\n  err: Possible<ComplexError>\n  is_promise: boolean\n}\n","import { ComplexError } from './ErrorList'\nimport { execute_callback } from './execute_callback'\nimport { ContextType } from '../context'\nimport { isAnyStage } from './types'\nimport {\n  AnyStage,\n  CallbackFunction,\n  Possible,\n  RunPipelineFunction,\n  StageObject,\n} from './types'\n\nexport function run_or_execute<T extends StageObject>(\n  stage: AnyStage<T> | RunPipelineFunction<T>,\n  err: Possible<ComplexError>,\n  context: ContextType<T>,\n  _done: CallbackFunction<T>,\n): void {\n  const done = ((err: Possible<ComplexError>, ctx: ContextType<T>) => {\n    _done(err, ctx ?? context)\n  }) as CallbackFunction<T>\n  if (isAnyStage<T>(stage)) {\n    stage.execute(err, context, done)\n  } else {\n    execute_callback<T>(err, stage, context, done)\n  }\n}\n","import { Stage } from './stage'\nimport { ComplexError, CreateError } from './utils/ErrorList'\nimport { run_or_execute } from './utils/run_or_execute'\nimport { ContextType } from './context'\nimport { isAnyStage } from './utils/types'\nimport {\n  AnyStage,\n  CallbackFunction,\n  Func2Sync,\n  Func3Sync,\n  Possible,\n  SingleStageFunction,\n  StageConfig,\n  StageObject,\n  StageRun,\n} from './utils/types'\n\nexport interface DoWhileConfig<T extends StageObject, R extends StageObject>\n  extends StageConfig<T> {\n  stage: AnyStage<T, R> | SingleStageFunction<T>\n  split?: Func2Sync<T, Possible<T>, number>\n  reachEnd?: Func3Sync<boolean, Possible<ComplexError>, Possible<T>, number>\n}\n\nexport class DoWhile<\n  T extends StageObject,\n  R extends StageObject,\n> extends Stage<T, DoWhileConfig<T, R>> {\n  constructor()\n  constructor(stage: Stage<T, StageConfig<T>>)\n  constructor(config: DoWhileConfig<T, R>)\n  constructor(stageFn: SingleStageFunction<T>)\n  constructor(\n    _config?:\n      | Stage<T, StageConfig<T>>\n      | DoWhileConfig<T, R>\n      | SingleStageFunction<T>,\n  ) {\n    let config: DoWhileConfig<T, R> = {} as DoWhileConfig<T, R>\n    if (isAnyStage<T, R>(_config)) {\n      config.stage = _config\n    } else if (typeof _config == 'function') {\n      config.stage = _config\n    } else {\n      if (_config?.run && _config?.stage) {\n        throw CreateError('use or run or stage, not both')\n      }\n\n      if (_config?.stage) {\n        config.stage = _config.stage\n      }\n\n      if (_config?.split instanceof Function) {\n        config.split = _config.split\n      }\n\n      if (_config?.reachEnd instanceof Function) {\n        config.reachEnd = _config.reachEnd\n      }\n    }\n    super(config)\n    this._config = {\n      ...this._config,\n      ...config,\n    }\n  }\n\n  public override get reportName() {\n    return `WHI:${this.config.name ? this.config.name : ''}`\n  }\n\n  public override toString() {\n    return '[pipeline DoWhile]'\n  }\n\n  reachEnd(\n    err: Possible<ComplexError>,\n    ctx: Possible<T>,\n    iter: number,\n  ): boolean {\n    if (this.config.reachEnd) {\n      return this.config.reachEnd(err, ctx, iter)\n    } else return true\n  }\n\n  split(ctx: Possible<T>, iter: number): any {\n    if (this.config.split) {\n      return this.config.split(ctx, iter)\n    } else return ctx\n  }\n\n  override compile(rebuild: boolean = false): StageRun<any> {\n    let run: StageRun<any> = (\n      err: Possible<ComplexError>,\n      context: ContextType<T>,\n      done: CallbackFunction<T>,\n    ) => {\n      let iter: number = -1\n      let next = (err: Possible<ComplexError>) => {\n        iter++\n        if (this.reachEnd(err, context, iter)) {\n          return done(err, context)\n        } else {\n          run_or_execute<T>(\n            this.config.stage,\n            err,\n            this.split(context, iter),\n            next as CallbackFunction<T>,\n          )\n        }\n      }\n      next(err)\n    }\n\n    this.run = run\n\n    return super.compile(rebuild)\n  }\n}\n","import { Stage } from './stage'\nimport { isAnyStage } from './utils/types'\nimport {\n  AllowedStage,\n  getEmptyConfig,\n  StageConfig,\n  StageObject,\n} from './utils/types'\nexport class Empty<T extends StageObject> extends Stage<T, StageConfig<T>> {\n  constructor(config: AllowedStage<T, T, StageConfig<T>>) {\n    super()\n    const res = getEmptyConfig(config)\n    if (isAnyStage<T>(res)) {\n      return res\n    } else {\n      this._config = res\n    }\n  }\n\n  public override toString() {\n    return '[pipeline Empty]'\n  }\n}\n","import { Stage } from './stage'\nimport { ComplexError } from './utils/ErrorList'\nimport { execute_validate } from './utils/execute_validate'\nimport { run_or_execute } from './utils/run_or_execute'\nimport {\n  AllowedStage,\n  getIfElseConfig,\n  IfElseConfig,\n  StageObject,\n} from './utils/types'\nimport { CallbackFunction, Possible, StageRun } from './utils/types'\nimport { ContextType } from './context'\n\nexport class IfElse<T extends StageObject> extends Stage<T, IfElseConfig<T>> {\n  constructor(config?: AllowedStage<T, T, IfElseConfig<T>>) {\n    super()\n    if (config) {\n      this._config = getIfElseConfig<T, IfElseConfig<T>>(config)\n    }\n  }\n\n  public override get reportName() {\n    return `Templ:${this.config.name ? this.config.name : ''}`\n  }\n\n  public override toString() {\n    return '[pipeline IfElse]'\n  }\n\n  override compile(rebuild: boolean = false): StageRun<T> {\n    let run: StageRun<T> = (\n      err: Possible<ComplexError>,\n      context: ContextType<T>,\n      done: CallbackFunction<T>,\n    ) => {\n      if (typeof this.config.condition == 'function') {\n        execute_validate<T>(this.config.condition, context, ((\n          err: Possible<ComplexError>,\n          condition: Possible<boolean>,\n        ) => {\n          if (condition) {\n            if (this.config.success) {\n              run_or_execute(this.config.success, err, context, done)\n            }\n          } else {\n            if (this.config.failed) {\n              run_or_execute(this.config.failed, err, context, done)\n            }\n          }\n        }) as CallbackFunction<boolean>)\n      } else if (typeof this.config.condition == 'boolean') {\n        if (this.config.condition) {\n          if (this.config.success) {\n            run_or_execute(this.config.success, err, context, done)\n          }\n        } else {\n          if (this.config.failed) {\n            run_or_execute(this.config.failed, err, context, done)\n          }\n        }\n      } else {\n        if (this.config.success) {\n          run_or_execute(this.config.success, err, context, done)\n        } else if (this.config.failed) {\n          run_or_execute(this.config.failed, err, context, done)\n        } else {\n          done(err, context)\n        }\n      }\n    }\n\n    this.run = run\n\n    return super.compile(rebuild)\n  }\n}\n","import { Stage } from './stage'\nimport { ComplexError, CreateError } from './utils/ErrorList'\nimport { run_or_execute } from './utils/run_or_execute'\nimport { ContextType } from './context'\nimport { isAnyStage } from './utils/types'\nimport {\n  AllowedStage,\n  AnyStage,\n  Func1,\n  Func1Sync,\n  Func2Sync,\n  getStageConfig,\n  isRunPipelineFunction,\n  RunPipelineFunction,\n  StageObject,\n} from './utils/types'\nimport {\n  CallbackFunction,\n  Possible,\n  StageConfig,\n  StageRun,\n} from './utils/types'\n\nexport type MultiWaySwitchCase<R extends StageObject, I extends StageObject> =\n  | MultiWaySwitchStatic<R, I>\n  | MultiWaySwitchDynamic<R, I>\n\nexport interface MultiWaySwitchStatic<\n  R extends StageObject,\n  I extends StageObject,\n> {\n  stage: AnyStage<I, I> | RunPipelineFunction<I>\n  evaluate?: boolean\n  split?: Func1Sync<ContextType<R>, ContextType<I>>\n  combine?: Func2Sync<ContextType<I>, ContextType<R>, any>\n}\n\nexport interface MultiWaySwitchDynamic<\n  T extends StageObject,\n  R extends StageObject,\n> {\n  stage: AnyStage<R, R> | RunPipelineFunction<R>\n  evaluate: Func1<boolean, R>\n  split?: Func1Sync<ContextType<T>, ContextType<R>>\n  combine?: Func2Sync<ContextType<R>, ContextType<R>, any>\n}\n\nexport function isMultiWaySwitch<T extends StageObject, R extends StageObject>(\n  inp: object,\n): inp is MultiWaySwitchCase<T, R> {\n  return (\n    typeof inp == 'object' &&\n    inp != null &&\n    'stage' in inp &&\n    isRunPipelineFunction((inp as { stage: any })['stage'])\n  )\n}\n\n//пересмотреть!!!!\nexport interface MultWaySwitchConfig<\n  T extends StageObject,\n  R extends StageObject,\n> extends StageConfig<T> {\n  cases: Array<MultiWaySwitchCase<R, StageObject>>\n  split?: Func1Sync<ContextType<R>, ContextType<StageObject>>\n  combine?: Func2Sync<ContextType<T>, Possible<T>, any>\n}\n\nexport type AllowedMWS<\n  T extends StageObject,\n  R extends StageObject,\n  C extends StageConfig<T>,\n> =\n  | AllowedStage<T, R, C>\n  | Array<Stage<T, C> | RunPipelineFunction<T> | MultiWaySwitchCase<T, R>>\n\nexport function getMultWaySwitchConfig<\n  T extends StageObject,\n  R extends StageObject,\n>(\n  config: AllowedMWS<T, R, Partial<MultWaySwitchConfig<T, R>>>,\n): MultWaySwitchConfig<T, R> {\n  if (Array.isArray(config)) {\n    return {\n      cases: config.map(item => {\n        let res: MultiWaySwitchCase<R, StageObject>\n        if (isRunPipelineFunction(item)) {\n          res = { stage: item, evaluate: true }\n        } else if (isAnyStage<T, R>(item)) {\n          res = {\n            stage: item as unknown as AnyStage<R, StageObject>,\n            evaluate: true,\n          }\n        } else if (isMultiWaySwitch<R, StageObject>(item)) {\n          res = item\n        } else {\n          throw CreateError('not suitable type for array in pipelin')\n        }\n        return res\n      }),\n    }\n  } else {\n    const res = getStageConfig(config)\n    if (isAnyStage<T, R>(res)) {\n      return { cases: [{ stage: res, evaluate: true }] }\n    } else if (typeof config == 'object' && !isAnyStage<T, R>(config)) {\n      if (config?.run && config.cases && config.cases.length > 0) {\n        throw CreateError(\" don't use run and stage both \")\n      }\n      if (config.run) {\n        res.cases = [{ stage: config.run, evaluate: true }]\n      }\n      if (config.cases) {\n        res.cases = config.cases\n      }\n      if (config.split) {\n        res.split = config.split\n      }\n      if (config.combine) {\n        res.combine = config.combine\n      }\n    } else if (typeof config == 'function' && res.run) {\n      res.cases = [{ stage: res.run, evaluate: true }]\n      delete res.run\n    }\n    if (typeof res.cases == 'undefined') res.cases = []\n    return res as MultWaySwitchConfig<T, R>\n  }\n}\n\nexport class MultiWaySwitch<\n  T extends StageObject,\n  R extends StageObject,\n> extends Stage<T, MultWaySwitchConfig<T, R>> {\n  constructor(config?: AllowedStage<T, R, MultWaySwitchConfig<T, R>>) {\n    super()\n    if (config) {\n      this._config = getMultWaySwitchConfig<T, R>(config)\n    }\n  }\n\n  public override get reportName() {\n    return `Templ:${this.config.name ? this.config.name : ''}`\n  }\n\n  public override toString() {\n    return '[pipeline MultWaySwitch]'\n  }\n\n  combine(ctx: ContextType<T>, retCtx: ContextType<R>): ContextType<T> {\n    if (this.config.combine) {\n      return this.config.combine(ctx, retCtx)\n    } else {\n      return ctx\n    }\n  }\n\n  combineCase(\n    item: MultiWaySwitchCase<R, StageObject>,\n    ctx: ContextType<R>,\n    retCtx: ContextType<StageObject>,\n  ): ContextType<T> {\n    if (item.combine) {\n      return item.combine(ctx, retCtx)\n    } else {\n      return this.combine(ctx, retCtx)\n    }\n  }\n\n  split(ctx: ContextType<T>): ContextType<R> {\n    if (this.config.split) {\n      return this.config.split(ctx)\n    } else {\n      return ctx\n    }\n  }\n\n  splitCase(\n    item: { split?: Func1Sync<any, ContextType<T>> },\n    ctx: ContextType<R>,\n  ): any {\n    if (item.split) {\n      return item.split(ctx)\n    } else {\n      return this.split(ctx)\n    }\n  }\n\n  override compile(rebuild: boolean = false): StageRun<T> {\n    let i\n    let statics: Array<MultiWaySwitchStatic<R, StageObject>> = []\n    let dynamics: Array<MultiWaySwitchDynamic<R, StageObject>> = []\n\n    // Apply to each stage own environment: evaluate, split, combine\n    for (i = 0; i < this.config?.cases?.length; i++) {\n      let caseItem: MultiWaySwitchCase<R, StageObject>\n      caseItem = this.config.cases[i]\n\n      if (caseItem instanceof Function) {\n        caseItem = {\n          stage: new Stage(caseItem),\n          evaluate: true,\n        } as MultiWaySwitchStatic<R, StageObject>\n      }\n\n      if (isAnyStage<R, StageObject>(caseItem)) {\n        caseItem = {\n          stage: caseItem,\n          evaluate: true,\n        }\n      }\n\n      if (caseItem.stage) {\n        if (caseItem.stage instanceof Function) {\n          caseItem.stage = caseItem.stage\n        }\n        if (\n          !isAnyStage<R, StageObject>(caseItem.stage) &&\n          typeof caseItem.stage == 'object'\n        ) {\n          caseItem.stage = new Stage(caseItem.stage)\n        }\n\n        if (!(caseItem.split instanceof Function)) {\n          caseItem.split = this.config.split\n        }\n        if (!(caseItem.combine instanceof Function)) {\n          caseItem.combine = this.config.combine\n        }\n\n        if (!('evaluate' in caseItem)) {\n          // by default is evaluate\n          caseItem.evaluate = true\n        }\n        if (typeof caseItem.evaluate === 'function') {\n          caseItem.evaluate\n          dynamics.push(caseItem as MultiWaySwitchDynamic<R, StageObject>)\n        } else if (\n          typeof caseItem.evaluate === 'boolean' &&\n          caseItem.evaluate\n        ) {\n          statics.push(caseItem as MultiWaySwitchStatic<R, StageObject>)\n        }\n      }\n    }\n\n    let run: StageRun<T> = (\n      err: Possible<ComplexError>,\n      ctx: ContextType<T>,\n      done: CallbackFunction<T>,\n    ) => {\n      let actuals: Array<MultiWaySwitchCase<R, StageObject>> = []\n      actuals.push.apply(actuals, statics)\n\n      for (let i = 0; i < dynamics.length; i++) {\n        if (dynamics[i].evaluate(ctx as T)) {\n          actuals.push(dynamics[i])\n        }\n      }\n\n      let iter = 0\n\n      let errors: Array<Error> = []\n      let hasError = false\n\n      let next = (index: number) => {\n        return (err: Possible<ComplexError>, retCtx: ContextType<R>) => {\n          iter++\n          let cur = actuals[index]\n          let res: Possible<ContextType<T>> = null\n          if (err) {\n            if (!hasError) hasError = true\n            errors.push(err)\n          } else {\n            res = this.combineCase(cur, ctx, retCtx)\n          }\n\n          if (iter >= actuals.length) {\n            return done(hasError ? CreateError(errors) : undefined, res ?? ctx)\n          }\n        }\n      }\n      let stg\n      let lctx\n      for (i = 0; i < actuals.length; i++) {\n        stg = actuals[i]\n        lctx = this.splitCase(stg, ctx)\n\n        run_or_execute<T>(stg.stage, err, lctx, next(i) as CallbackFunction<T>)\n        // не хватает явной передачи контекста\n      }\n\n      if (actuals.length === 0) {\n        return done(err)\n      }\n    }\n\n    this.run = run\n\n    return super.compile(rebuild)\n  }\n}\n","import { Stage } from './stage'\nimport { empty_run } from './utils/empty_run'\nimport { ComplexError, CreateError } from './utils/ErrorList'\nimport { run_or_execute } from './utils/run_or_execute'\nimport { ContextType } from './context'\nimport {\n  AllowedStage,\n  CallbackFunction,\n  getParallelConfig,\n  ParallelConfig,\n  Possible,\n  StageObject,\n  StageRun,\n} from './utils/types'\n\n/**\n * Process staging in parallel way\n * ### config as _Object_\n *\n * - `stage`\n * \t\tevaluating stage\n * - `split`\n * \t\tfunction that split existing stage into smalls parts, it needed\n * - `combine`\n * \t\tif any result combining is need, this can be used to combine splited parts and update context\n *\n * > **Note**\n * \t\t`split` does not require `combine` it will return parent context;\n * \t\tin cases that have no declaration for `split` configured or default will be used\n *\n * @param {Object} config configuration object\n */\nexport class Parallel<\n  T extends StageObject,\n  R extends StageObject,\n> extends Stage<T, ParallelConfig<T, R>> {\n  constructor(config?: AllowedStage<T, R, ParallelConfig<T, R>>) {\n    super()\n    if (config) {\n      this._config = getParallelConfig<T, R>(config)\n    }\n  }\n\n  split(ctx: ContextType<T>): Array<ContextType<R>> {\n    return this._config.split ? this._config.split(ctx) : [ctx]\n  }\n\n  combine(\n    ctx: ContextType<T>,\n    children: Array<ContextType<R>>,\n  ): ContextType<T> {\n    let res: ContextType<T>\n    if (this.config.combine) {\n      let c = this.config.combine(ctx, children)\n      res = c ?? ctx\n    } else {\n      res = ctx\n    }\n    return res\n  }\n\n  public override get reportName() {\n    return `PLL:${this.config.name ? this.config.name : ''}`\n  }\n  public override toString() {\n    return '[pipeline Pipeline]'\n  }\n\n  public override get name(): string {\n    return this._config.name ?? this._config.stage?.name ?? ''\n  }\n\n  override compile(rebuild: boolean = false): StageRun<T> {\n    if (this.config.stage) {\n      var run: StageRun<T> = (\n        err: Possible<ComplexError>,\n        ctx: ContextType<T>,\n        done: CallbackFunction<T>,\n      ) => {\n        var iter = 0\n        var children = this.split(ctx)\n        var len = children ? children.length : 0\n        let errors: Array<Error>\n        let hasError = false\n\n        var next = (index: number) => {\n          return (err: Possible<ComplexError>, retCtx: any) => {\n            if (!err) {\n              children[index] = retCtx ?? children[index]\n            } else {\n              if (!hasError) {\n                hasError = true\n                errors = []\n              }\n              const error = new ParallelError({\n                stage: this.name,\n                index: index,\n                err: err,\n                ctx: children[index],\n              })\n              if (error) errors.push(error)\n            }\n\n            iter += 1\n            if (iter >= len) {\n              if (!hasError) {\n                let result = this.combine(ctx, children)\n                return done(undefined, result)\n              } else {\n                return done(CreateError(errors), ctx)\n              }\n            }\n          }\n        }\n\n        if (len === 0) {\n          return done(err, ctx)\n        } else {\n          for (var i = 0; i < len; i++) {\n            run_or_execute(\n              this.config.stage,\n              err,\n              children[i],\n              next(i) as CallbackFunction<T>,\n            )\n          }\n        }\n      }\n      this.run = run\n    } else {\n      this.run = empty_run\n    }\n\n    return super.compile()\n  }\n}\n\nexport type ParallelErrorInput = {\n  stage?: string\n  index: number\n  err: Error\n  ctx: any\n}\n\nexport class ParallelError<T> extends Error {\n  override name: string\n  stage?: string\n  index: number\n  err: Error\n  ctx: T\n  constructor(init: ParallelErrorInput) {\n    super(init.err.message)\n    this.name = 'ParallerStageError'\n    this.stage = init.stage\n    this.ctx = init.ctx\n    this.err = init.err\n    this.index = init.index\n  }\n  override toString() {\n    return `${this.name}: at stage ${this.stage} error occured:\n    iteration ${this.index}\n    ${this.err.message}\n    stack is: ${this.err.stack}`\n  }\n}\n","import { Stage } from './stage'\nimport { empty_run } from './utils/empty_run'\nimport { ComplexError } from './utils/ErrorList'\nimport { run_or_execute } from './utils/run_or_execute'\nimport { ContextType } from './context'\nimport { isAnyStage } from './utils/types'\nimport {\n  AnyStage,\n  getPipelinConfig,\n  Possible,\n  StageObject,\n} from './utils/types'\nimport {\n  AllowedStage,\n  CallbackFunction,\n  PipelineConfig,\n  RunPipelineFunction,\n  StageConfig,\n  StageRun,\n} from './utils/types'\n\n/**\n * it make possible to choose which stage to run according to result of `condition` evaluation\n *  - config as\n \t\t- `Function` --- first Stage for pipeline\n * \t\t- `Stage` --- first Stage\n * \t\t- `Array` --- list of stages\n * \t\t- `Object` --- config for Pipeline\n *\t\t\t  - `stages` list of stages\n *\t\t\t  - `name` name of pipeline\n * \t\t- `Empty` --- empty pipeline\n *\n * @param {Object} config configuration object\n */\nexport class Pipeline<T extends StageObject> extends Stage<\n  T,\n  PipelineConfig<T>\n> {\n  constructor(\n    config?:\n      | PipelineConfig<T>\n      | AllowedStage<T, T, PipelineConfig<T>>\n      | Array<Stage<T, PipelineConfig<T>> | RunPipelineFunction<T>>,\n  ) {\n    super()\n    if (config) {\n      this._config = getPipelinConfig(config)\n    } else {\n      this._config.stages = []\n    }\n  }\n\n  public override get reportName() {\n    return `PIPE:${this.config.name ? this.config.name : ''}`\n  }\n\n  addStage<IT extends StageObject>(\n    _stage: StageConfig<IT> | RunPipelineFunction<IT> | AnyStage<IT>,\n  ) {\n    let stage: AnyStage<IT> | RunPipelineFunction<IT> | undefined\n    if (typeof _stage === 'function') {\n      stage = _stage\n    } else {\n      if (typeof _stage === 'object') {\n        if (isAnyStage<IT>(_stage)) {\n          stage = _stage\n        } else {\n          stage = new Stage(_stage)\n        }\n      }\n    }\n    if (stage) {\n      this.config.stages.push(stage as any)\n      this.run = undefined\n    }\n  }\n\n  public override toString() {\n    return '[pipeline Pipeline]'\n  }\n\n  override compile(rebuild: boolean = false): StageRun<T> {\n    let run: StageRun<T> = (\n      err: Possible<ComplexError>,\n      context: ContextType<T>,\n      done: CallbackFunction<T>,\n    ) => {\n      let i = -1\n      // sequential run;\n      let next = (err: Possible<ComplexError>, ctx: ContextType<T>) => {\n        i += 1\n        if (!err && i < this.config.stages.length) {\n          const st = this.config.stages[i]\n          run_or_execute<T>(\n            st,\n            err,\n            ctx ?? context,\n            next as CallbackFunction<T>,\n          )\n        } else if (i >= this.config.stages.length || err) {\n          done(err, ctx ?? context)\n        }\n      }\n      next(err, context)\n    }\n\n    if (this.config.stages.length > 0) {\n      this.run = run\n    } else {\n      this.run = empty_run\n    }\n\n    return super.compile(rebuild)\n  }\n}\n","import { Context, ContextType } from './context'\nimport { Stage } from './stage'\nimport { ComplexError, CreateError } from './utils/ErrorList'\nimport { run_or_execute } from './utils/run_or_execute'\nimport {\n  AllowedStage,\n  AnyStage,\n  getStageConfig,\n  Possible,\n  RunPipelineFunction,\n  StageObject,\n} from './utils/types'\nimport {\n  CallbackFunction,\n  Func3,\n  StageConfig,\n  StageRun,\n  isAnyStage,\n} from './utils/types'\n\nexport interface RetryOnErrorConfig<T extends StageObject>\n  extends StageConfig<T> {\n  stage: AnyStage<T> | RunPipelineFunction<T>\n  retry: number | Func3<boolean, Possible<ComplexError>, ContextType<T>, number>\n  backup?: (ctx: ContextType<T>) => ContextType<T>\n  restore?: (ctx: ContextType<T>, backup: ContextType<T>) => ContextType<T>\n}\n\nexport function getRetryOnErrorConfig<\n  T extends StageObject,\n  C extends RetryOnErrorConfig<T>,\n>(config: AllowedStage<T, T, C>): C {\n  const res = getStageConfig<T, T, C>(config)\n  if (isAnyStage<T, C>(res)) {\n    return { stage: res } as C\n  } else if (typeof config == 'object' && !isAnyStage<T, C>(config)) {\n    if (config.run && config.stage) {\n      throw CreateError(\"don't use run and stage both\")\n    }\n    if (config.run) {\n      res.stage = config.run\n    }\n    if (config.stage) {\n      res.stage = config.stage\n    }\n    if (config.backup) {\n      res.backup = config.backup\n    }\n    if (config.restore) {\n      res.restore = config.restore\n    }\n    if (config.retry) {\n      if (typeof config.retry !== 'function') {\n        config.retry *= 1 // To get NaN is wrong type\n      }\n      res.retry = config.retry\n    }\n    if (!res.retry) res.retry = 1\n  } else if (typeof config == 'function' && res.run) {\n    res.stage = res.run\n    delete res.run\n  }\n  return res\n}\n\nexport class RetryOnError<T extends StageObject> extends Stage<\n  T,\n  RetryOnErrorConfig<T>\n> {\n  constructor(config?: AllowedStage<T, T, RetryOnErrorConfig<T>>) {\n    super()\n    if (config) {\n      this._config = getRetryOnErrorConfig<T, RetryOnErrorConfig<T>>(config)\n    }\n  }\n\n  public override get reportName() {\n    return `Templ:${this.config.name ? this.config.name : ''}`\n  }\n\n  public override toString() {\n    return '[pipeline RetryOnError]'\n  }\n\n  backupContext(ctx: ContextType<T>): ContextType<T> {\n    if (this.config.backup) {\n      return this.config.backup(ctx)\n    } else {\n      if (Context.isContext(ctx)) {\n        return ctx.fork({})\n      } else {\n        return ctx\n      }\n    }\n  }\n\n  restoreContext(ctx: ContextType<T>, backup: ContextType<T>): ContextType<T> {\n    if (this.config.restore) {\n      return this.config.restore(ctx, backup)\n    } else {\n      if (Context.isContext(ctx)) {\n        for (let key in backup) {\n          ;(ctx as any)[key] = backup[key]\n        }\n        return ctx\n      } else {\n        return backup\n      }\n    }\n  }\n\n  override compile(rebuild: boolean = false): StageRun<T> {\n    let run: StageRun<T> = (\n      err: Possible<ComplexError>,\n      ctx: ContextType<T>,\n      done: CallbackFunction<T>,\n    ) => {\n      /// ловить ошибки\n      // backup context object to overwrite if needed\n      let backup = this.backupContext(ctx)\n\n      const reachEnd = (err: Possible<ComplexError>, iter: number) => {\n        if (err) {\n          if (this.config.retry instanceof Function) {\n            return !this.config.retry(err, ctx, iter)\n          } else {\n            // number\n            return iter > this.config.retry\n          }\n        } else {\n          return true\n        }\n      }\n      let iter = -1\n\n      let next = (err: Possible<ComplexError>, _ctx: ContextType<T>) => {\n        iter++\n        if (reachEnd(err, iter)) {\n          return done(err, _ctx ?? ctx)\n        } else {\n          // clean changes of existing before values.\n          // may be will need to clear at all and rewrite ? i don't know yet.\n          const res = this.restoreContext(_ctx ?? ctx, backup)\n          run_or_execute(\n            this.config.stage,\n            err,\n            res ?? ctx,\n            next as CallbackFunction<T>,\n          )\n        }\n      }\n      run_or_execute(this.config.stage, err, ctx, next as CallbackFunction<T>)\n    }\n\n    this.run = run\n\n    return super.compile(rebuild)\n  }\n}\n","import { Stage } from './stage'\nimport { empty_run } from './utils/empty_run'\nimport { ComplexError } from './utils/ErrorList'\nimport { run_or_execute } from './utils/run_or_execute'\nimport { ContextType } from './context'\nimport {\n  AllowedStage,\n  CallbackFunction,\n  getParallelConfig,\n  ParallelConfig,\n  Possible,\n  StageObject,\n  StageRun,\n} from './utils/types'\n\n/**\n * Process staging in Sequential way\n * ### config as _Object_\n *\n * - `stage`\n * \t\tevaluating stage\n * - `split`\n * \t\tfunction that split existing stage into smalls parts, it needed\n * - `combine`\n * \t\tif any result combining is need, this can be used to combine splited parts and update context\n *\n * > **Note**\n * \t\t`split` does not require `combine` it will return parent context;\n * \t\tin cases that have no declaration for `split` configured or default will be used\n *\n * @param {Object} config configuration object\n */\nexport class Sequential<\n  T extends StageObject,\n  R extends StageObject,\n> extends Stage<T, ParallelConfig<T, R>> {\n  constructor(config?: AllowedStage<T, R, ParallelConfig<T, R>>) {\n    super()\n    if (config) {\n      this._config = getParallelConfig(config)\n    }\n  }\n\n  split(ctx: ContextType<T>): Array<ContextType<R>> {\n    return this._config.split ? this._config.split(ctx) : [ctx]\n  }\n\n  combine(\n    ctx: ContextType<T>,\n    children: Array<ContextType<R>>,\n  ): ContextType<T> {\n    let res: ContextType<T>\n    if (this.config.combine) {\n      let c = this.config.combine(ctx, children)\n      res = c ?? ctx\n    } else {\n      res = ctx\n    }\n    return res\n  }\n\n  public override get reportName() {\n    return `PLL:${this.config.name ? this.config.name : ''}`\n  }\n  public override toString() {\n    return '[pipeline Pipeline]'\n  }\n\n  public override get name(): string {\n    return this._config.name ?? this._config.stage?.name ?? ''\n  }\n\n  override compile(rebuild: boolean = false): StageRun<T> {\n    if (this.config.stage) {\n      var run = (\n        err: Possible<ComplexError>,\n        ctx: ContextType<T>,\n        done: CallbackFunction<T>,\n      ) => {\n        var iter = -1\n        var children = this.split\n          ? this.split(ctx)\n          : [ctx as unknown as ContextType<R>]\n        var len = children ? children.length : 0\n\n        var next = (err: Possible<ComplexError>, retCtx?: ContextType<R>) => {\n          if (err) {\n            return done(err)\n          }\n\n          if (retCtx) {\n            children[iter] = retCtx\n          }\n\n          iter += 1\n          if (iter >= len) {\n            let result = this.combine(ctx, children)\n            return done(undefined, result)\n          } else {\n            run_or_execute(\n              this.config.stage,\n              err,\n              children[iter],\n              next as CallbackFunction<T>,\n            )\n          }\n        }\n\n        if (len === 0) {\n          return done(err, ctx)\n        } else {\n          next(err)\n        }\n      }\n\n      this.run = run\n    } else {\n      this.run = empty_run\n    }\n\n    return super.compile()\n  }\n}\n","import { Stage } from './stage'\nimport { ComplexError } from './utils/ErrorList'\nimport { run_or_execute } from './utils/run_or_execute'\nimport { AllowedStage, getTimeoutConfig, StageObject } from './utils/types'\nimport { ContextType } from './context'\nimport {\n  CallbackFunction,\n  Possible,\n  StageRun,\n  TimeoutConfig,\n} from './utils/types'\n\nexport class Timeout<T extends StageObject> extends Stage<T, TimeoutConfig<T>> {\n  constructor(config?: AllowedStage<T, T, TimeoutConfig<T>>) {\n    super()\n    if (config) {\n      this._config = getTimeoutConfig<T>(config)\n    }\n  }\n\n  public override get reportName() {\n    return `Templ:${this.config.name ? this.config.name : ''}`\n  }\n\n  public override toString() {\n    return '[pipeline Timeout]'\n  }\n\n  override compile(rebuild: boolean = false): StageRun<T> {\n    let run: StageRun<T> = (\n      err: Possible<ComplexError>,\n      ctx: ContextType<T>,\n      done: CallbackFunction<T>,\n    ) => {\n      let to: any\n      let localDone = ((\n        err: Possible<ComplexError>,\n        retCtx: ContextType<T>,\n      ) => {\n        if (to) {\n          clearTimeout(to)\n          to = null\n          return done(err, retCtx)\n        }\n      }) as CallbackFunction<T>\n      let waitFor\n\n      if (this.config.timeout instanceof Function) {\n        waitFor = this.config.timeout(ctx)\n      } else {\n        waitFor = this.config.timeout\n      }\n      if (waitFor) {\n        to = setTimeout(() => {\n          if (to) {\n            if (this.config.overdue) {\n              run_or_execute(this.config.overdue, err, ctx, localDone)\n            }\n          }\n          /* else {\n            here can be some sort of caching operation\n          }*/\n        }, waitFor)\n        if (this.config.stage) {\n          run_or_execute(this.config.stage, err, ctx, localDone)\n        }\n      } else {\n        if (this.config.stage) {\n          run_or_execute(this.config.stage, err, ctx, done)\n        }\n      }\n    }\n\n    this.run = run\n\n    return super.compile(rebuild)\n  }\n}\n","import { ContextType } from './context'\nimport { Stage } from './stage'\nimport { ComplexError } from './utils/ErrorList'\nimport { run_or_execute } from './utils/run_or_execute'\nimport {\n  getWrapConfig,\n  Possible,\n  StageObject,\n  AllowedStage,\n  CallbackFunction,\n  StageRun,\n  WrapConfig,\n} from './utils/types'\n\nexport class Wrap<T extends StageObject, R extends StageObject> extends Stage<\n  T,\n  WrapConfig<T, R>\n> {\n  constructor(config?: AllowedStage<T, R, WrapConfig<T, R>>) {\n    super()\n    if (config) {\n      this._config = getWrapConfig<T, R, WrapConfig<T, R>>(config)\n    }\n  }\n\n  public override get reportName() {\n    return `Wrap:${this.config.name ? this.config.name : ''}`\n  }\n\n  public override toString() {\n    return '[pipeline Wrap]'\n  }\n\n  override compile(rebuild: boolean = false): StageRun<T> {\n    let run = (\n      err: Possible<ComplexError>,\n      context: ContextType<T>,\n      done: CallbackFunction<T>,\n    ) => {\n      const ctx = this.prepare(context)\n      if (this.config.stage) {\n        run_or_execute<any>(this.config.stage, err, ctx, ((\n          err: Possible<ComplexError>,\n          retCtx: ContextType<R>,\n        ) => {\n          if (!err) {\n            const result = this.finalize(context, retCtx ?? ctx)\n            done(undefined, result ?? context)\n          } else {\n            done(err, context)\n          }\n        }) as CallbackFunction<T>)\n      }\n    }\n\n    this.run = run\n\n    return super.compile(rebuild)\n  }\n  prepare(ctx: ContextType<T>): unknown {\n    if (this.config.prepare) {\n      return this.config.prepare(ctx) ?? ctx\n    } else {\n      return ctx\n    }\n  }\n  finalize(ctx: ContextType<T>, retCtx: ContextType<R>): ContextType<T> {\n    // by default the main context will be used to return;\n    if (this.config.finalize) {\n      return this.config.finalize(ctx, retCtx)\n    } else {\n      // so we do nothing here\n      return ctx\n    }\n  }\n}\n"],"names":["ContextSymbol","Symbol","OriginalObject","ProxySymbol","RESERVATIONS","prop","func_this","func_ctx","RESERVED","getParent","getRoot","setParent","setRoot","toString","original","__parent","__root","__stack","hasChild","hasSubtree","ensure","addChild","addSubtree","toJSON","toObject","fork","get","allContexts","count","Context","_config","isContext","obj","ctx","child","proxy","path","root","Object","result","lctx","set","parent","defaultsDeep","JSON","stringify","constructor","config","id","res","Proxy","target","key","_proxy","bind","value","deleteProperty","has","ownKeys","Reflect","CreateError","err","ComplexError","Error","Array","isArray","filter","e","forEach","ler","payload","push","length","isComplexError","inp","isComplex","empty_run","context","done","isCallback","is_async_function","isExternalCallback","name","is_func1Callbacl","is_async","is_func0","is_func1","is_func2","is_func3","is_func0_async","is_func1_async","is_func2_async","is_func3_async","is_thenable","isSingleStageFunction","isRunPipelineFunction","isRescue","isValidateFunction","isEnsureFunction","isStageRun","isAllowedStage","isAnyStage","getStageConfig","run","getNameFrom","rescue","validate","schema","compile","precompile","ajv","Ajv","allErrors","ajvFormats","ajvErrors","singleError","ajvKeywords","errors","errorsText","match","getPipelinConfig","stages","map","item","getParallelConfig","stage","r","split","combine","getEmptyConfig","getWrapConfig","finalize","prepare","getTimeoutConfig","timeout","overdue","getIfElseConfig","success","condition","failed","isStage","can_fix_error","ERROR","signature","invalid_context","process_error","String","run_callback_once","wrapee","done_call","c","execute_callback","_done","call","then","undefined","catch","apply","Promise","_","execute_custom_run","execute_ensure","execute_rescue","execute_validate","StageSymbol","Stage","reportName","runStageMethod","err_","stageToRun","callback","rescuedContext","execute","_err","_context","_callback","not_ensured_context","__callback","arguments","legacy","input_is_context","rej","back","_ctx","process","nextTick","sucess","ret","fail","retErr","rebuild","run_or_execute","DoWhile","reachEnd","iter","next","Function","Empty","IfElse","isMultiWaySwitch","getMultWaySwitchConfig","cases","evaluate","MultiWaySwitch","retCtx","combineCase","splitCase","i","statics","dynamics","caseItem","actuals","hasError","index","cur","stg","Parallel","children","len","error","ParallelError","message","stack","init","Pipeline","addStage","_stage","st","getRetryOnErrorConfig","backup","restore","retry","RetryOnError","backupContext","restoreContext","Sequential","Timeout","to","localDone","clearTimeout","waitFor","setTimeout","Wrap"],"mappings":"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"}