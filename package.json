{
  "name": "pipeline.js",
  "description": "Pipeline.js - async workflow framework for node.js",
  "version": "0.0.29",
  "author": {
    "name": "Alex Vedmedenko",
    "email": "vedmalex@gmail.com"
  },
  "keywords": [
    "workflow",
    "async",
    "pipeline"
  ],
  "dependencies": {
    "js-schema": "0.6.1"
  },
  "devDependencies": {
    "mocha": "*",
    "benchmark": "*",
    "browserify": "*"
  },
  "directories": {
    "lib": "./lib"
  },
  "scripts": {
    "test": "make test"
  },
  "main": "./index.js",
  "engines": {
    "node": ">= 0.4.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/vedmalex/pipeline.js.git"
  },
  "readme": "#Цель:  библиотека для повторного использования кода и упрощенного тестировани.\nпо сути не отличается от обычного модульного программирования. \nосновное преимущество, можно комбинировать код простым добавлением новых видов stage/pipline и их последующее использование в процессе работы.\n\nPipeline с именованными шагами, для того чтобы иметь возможность создавать возвраты.\nдля этого необходим либо новая ходилка по шагам либо своя ходилка по шагам.\n\n - дополнительные стандартные stage условный переход\n\n - возможность возврата на любой шаг вперед и назад \n \n - возможность задать следующий шаг\n\n - операции типа split combine для параллельного выполнения и задания точек синхронизации\n(типа сети петри)\n\n - обработка ошибок: должна быть отделена от основного механизма хождения по шагам, для того чтобы можно было установить новый следующий шаг в случае ошибки, либо выбрать шаги из другого списка шагов... по усмотрению разработчика.\n\n - возможность сериализовать структуру stage в файл.\n\n - останавливать выполнение stage (workflow);\n\n#Требования к параллельному и к последовательному испольнению\n1. последовательно:\n\t- последовательно обработать массив конекстов.\n\t- stage который выполнит по\n\nэто специальный тип pipeline.\n\n##Sequential\n\nStage с параметрами:\n\n- stage - Stage который будет выполняться внутри.\n\n- fork - процедура процедура которая делает fork текущего context-а для stage, или создает новый, может быть и на основен текущего, в зависимости от необходимости, и заполняет его специфичными данными.\n\n- reachEnd - условие завершения последовательности.\n- combine - метод который будет формировать результирующий контекст.\n\n##Parallel\nc parallel все немного сложнее... проблема в том, что нужно будет предварительно создать все котексты и запустить из обработку... поэтмоу, возможно, в нем нет необходимости. НО!\n\n- stage - Stage который будет выполняться внутри.\n\n- fork - процедура процедура, которая сформирует массив конектстов, которые должны будут выполниться параллельно. Работает на основе fork текущего context-а для stage, или создает новый, может быть и на основен текущего, в зависимости от необходимости, и заполняет его специфичными данными.\n- combine - метод который будет формировать результирующий контекст.\n\n##IFELSE\n\nStage с параметрами\n\n- condition - функция, которая на основании текущего контекта вычисляет условие.\n\n- succeess - Stage, который выполняется в случае condition(ctx) = true;\n\n- failed - , который выполняется в случае condition(ctx) = false;\n\n#SWITCH \n\nStage с параметрами\n\n- condition - функция определяет строку для выборки условия.\n\n- cases - пары {значение:Stage}\n\n- defaults - ни один из перечисленных\n\n\nобработка ошибок:\n\nвсе последовательные операции обрываются после первой ошибки.\nвсе параллельные операции выполняются до конца, и ошибки суммируются.\n\nзаписывать путь, который прошел контекст по конвееру - лог. чтобы было видно как и где и что.\n\nhttps://twitter.com/NodeDublin/status/301307831133540352?uid=75756871&iid=fd641cec-8801-44b6-95fc-ff116de470a6&nid=12+595+20130212\nможет быть использовать stream? или что-то такое\nhttps://github.com/substack/stream-handbook, это позволит уйти от callback и вывести управление ошибками отдельно...\nскорее всего у меня все готово для этого... может быть придется чего то менять...\n\nunwind делает сплит по всем вложенным полям объекта.\n\n\nвсякие правила удаления нужно проверять как раз на этапе подгрузки данных на сервер. и только для удаления...\nподготовку к удалению разделить на три метода, 1. обычное, 2. аггрегация, 3. композиция.... придумать как их удалять. поскольку в одном случает ассоциация требует удаления всех связанных, в другом, запрещает удаление при наличии хотя бы одного элемента.\n\n???при создании элемента ключа у объекта может не быть.... и посмотреть транзакцию со встроенными объектами -- правда получиться что-то типа того, как я делал с импортом схемы.\n\nподумать стоит ли загружать объекты связи.... соменваюсь.\n\nс новой транзакцией можно задавать механизмы для сохранения объектов и прочее.\n\nи следует поменять машину состояний или вообще убрать...\n\n\nконтекст надо оборачивать вокруг класса.\nсоздавая для него проперти. тогда для некоторых вещей не надо будет делать обращения через getParent()\n\nсделать версию для browser\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/vedmalex/pipeline.js/issues"
  },
  "_id": "pipeline.js@0.0.29",
  "_from": "pipeline.js@"
}
