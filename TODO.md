TODO1
посмотреть можно ли как-то сгерерить функцию по описанию pipeline
чтобы пропустить этап формирования кода через сложные вызовы

ведь все просто

принимать promises в качестве параметров

moving to ZOD + ts 4.9

ВСЯ внутренняя работа идет ТОЛЬКО с Context

все параметры по внешним функциям идут ТОЛЬКО через Context

отличаем внешние от внутренних
и stageRun и прочее

размер стека???!!! что с ним делать

если есть
split T->R
тогда два параметра
combine R->T
validate R

добавить fluent pipeline так методы будут легче распознавать типы

- так сделать в trpc.js

убрать instanceof XXX сравнения, эти классы компилятся в ecmascript-5 а так нет таких штук!!! просто придумать как сделать и заменить эти хрени

компиляция в ES5 сделана для совместимости

убрать систему callback и оставить только promise !!!!

для синхронных вызовов использовать
Promise.AllSettled Promise.resolve(значение)

Посмотреть все TODO!!!
работать по тестам

к чему идем!
запрет использования constructor + только через builder!
все тесты только через него!!!

сначала упростить! потом подключить ZOD на все параметры конфига чтобы валидировать

шаг 1
[x] combine должны возвращать результат!!!
[x] split должен возвращать результат
[x] validate должен быть очень простым!!! никаких множества вариантов принимает контектс возвращает MaybePromise<boolean>

если run вываливается с ошибкой и нет rescue то контекст и не нужен

- ifelse
- multiwayswitch
- doWhile
- retry

rescue должен быть простым и быть как можно ближе к stage

- похоже rescue не нужна совсем?(мысли)
- нужна для экстренных вещей, используется в Transaction!!! для сбора информации об ошибках

[] run MaybePromise(output)
stage function должена принимать контекст и возврашать значение
metable immutable это решение за программистом, он сам выбирает как ему быть

[] убрать этам compile
-- нужно чтобы просто переопределялся run
-- пусть работает динамически, а не статически

возможно context как таковой не нужен, тогда и не нужно его передавать и обертку делать context внутри
все операции можно делать средствами JS
-- эта штука активно исползуется в web

сложность, что должна быть точка сборки контекста!!! это не из коробки и это должно быть как-то обыграно
combine модифицирует входящий контекст
последовательность операций combine в сложных stage определяется порядоком в массиве stages/cases

поскольку не мутабельный объект не меняется поэтому нужно четко отслеживать точку сборки общего контекста

ВОЗМОЖНО!!! нужно будет сделать Override Class
что бы можно было запускать Stage через new
--- пример есть в Model Import/Export - где модель создается динамически

Input + Output

(Input) => MaybePromise<Output>

Input + !Output

(Input) => MaybePromise<void>

!Input + !Output

no run

использовать везде Promise

никаких callback!!!

всю внутренню кухню только сделать на Promise allSellted!

RESCUE не нужен сама функция будет возвращать результат выполнения и необходимую информацию, которую можно обработать как-то позже

- нужен для того чтобы как-то благоприятно обработать ошибку, возможно отменить какое-то действие или сформировать код ошибки
- или принять, какое-то решение
- например для того чтобы заполнить поле ошибок в контектсе и пойти дальше

тип CallbackArgs<Input, Output> является внутреним транспортом используется для отслеживания?

RESCUE отдельный вид Stage

работает как Wrap

сделать базовый stage от которого будут все классы работать
[] решил по другому, параметры теперь просто классы

err всегда должен быть типа Error!!!
чтобы увидеть где ошибка произошла в стеке

//
извлечение параметров из структуры типов
-- можно при связывании stage и вложенных типов делиться информацией
-- проверять что stage не первый в очереди/массиве и на основе этого извлекать из него Input и Output
-- как правило выход одного параметра должен быть входом другого
отсюда можно уменьшить работы между ними
--- так же можно сигнализировать о совместимости входов и выходов если они не соответсвуют друг другу

можно использовать тот же принцип и для Fte.js

для того чтообы гарантировать наличие необходимых типов

RateLimit - блок который будет проверять, насколько часто обращался к ресурсу по вычисляемым
Cache - блок который будет кэшировать результаты вложенных вычислений если пришли те же параметры
patternMatch - похоже на MWS

if else
при отсутсвии else необходимо проверять совместимость типов между собой
например если вход и выход на success разные, то может произойти ошибка поэтому нужно выдать требование поставить else условие
