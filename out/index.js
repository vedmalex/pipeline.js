// @bun
import L from"zod";import{fromZodError as TI} from"zod-validation-error";function mI(I){return typeof I==="object"&&I!==null&&("result"in I)&&(I.result==="success"||I.result==="success_empty"||I.result==="failure")}function w(I,T){let P;if(I)if(I instanceof Error)P={result:"failure",reason:I,input:T};else throw new Error("error must be Error type");else if(T)P={result:"success",output:T};else P={result:"success_empty"};return P}function EI(I){return function(T){switch(!0){case T.result==="success":I(void 0,T.output);break;case T.result==="success_empty":I(void 0,void 0);break;case T.result==="failure":I(T.reason,T.input)}}}function wI(I){return(T,P)=>{I(w(T,P))}}import Y from"zod";function II(I){if(I instanceof M)return!0;else if(typeof I=="object"&&I&&("isComplex"in I)&&("payload"in I)&&Array.isArray(I.payload)&&I.isComplex)return!0;else return!1}function W(I){const T=Y.union([Y.instanceof(Error),Y.instanceof(M),Y.object({}).passthrough(),Y.string(),Y.null(),Y.undefined()]),P=Y.union([T,Y.array(T)]).parse(I);if(typeof P=="string")return new M(new Error(P));if(typeof P=="object"&&P!==null){if(Array.isArray(P)){let F=[];if(P.filter((U)=>U).forEach((U)=>{const J=W(U);if(J)if(J.payload)F.push(...J.payload);else F.push(J)}),F.length>1)return new M(...F);if(F.length===1)return F[0]}else if(P)if(II(P))return P;else return new M(P)}}class M extends Error{payload;isComplex;constructor(...I){super();this.payload=I,this.isComplex=!0}}var Z={signature:"unacceptable run method signature",invalid_context:"context is invalid",argements_error:"arguments Error",not_implemented:"not implemented",rescue_MUST_return_value:"rescue MUST return value",define_stage_before_use_of_rescue:"define stage before use of rescue",operation_timeout_occured:"operation timeout occured"};class k extends Error{index;err;ctx;constructor(I){super();this.name="ParallerStageError",this.ctx=I.ctx,this.err=I.err,this.index=I.index}toString(){return`iteration ${this.index}
    ${this.err}`}}function c(I,T){const P=I?I:L.any(),F=T?T:P;return L.function(L.tuple([L.object({input:P})]),L.union([F.promise(),F]))}function H(I){const T=I?.input?I.input:L.any(),P=I?.output?I.output:T;return L.object({run:c(T,P)})}var G=L.object({input:L.instanceof(L.ZodType).optional(),output:L.instanceof(L.ZodType).optional()});class O{_config;get config(){return this._config}set config(I){this._config=I}get run(){return this._config.run}set run(I){this._config.run=I}constructor(I){if(typeof I==="object"&&I!==null)this._config=I,this._config.run=this._config.run.bind(this);else throw new Error(Z.argements_error);this.exec=this.exec.bind(this)}async exec({input:I}){if(this._config.input){const P=await this.validate(this._config.input,I);if(P.result==="failure")throw P.reason}const T=await c(this.config.input,this.config.output).parse(this._config.run)({input:I});if(this._config.output){const P=await this.validate(this._config.output,T);if(P.result==="failure")throw P.reason}return T}async execute(I){return this.exec({input:I})}async validate(I,T){const P=await I.safeParseAsync(T);if(!P.success)return w(TI(P?.error),T);else return w(void 0,T)}}import j from"zod";async function PI({input:I}){let T=0,P=I;do{let F=this.config.step?await this.config.step({input:I,iteration:T}):I,U=await this.config.do.exec({input:F});P=await this.config.combine({input:I,result:U,output:P,iteration:T}),T+=1}while(this.config.while({input:I,iteration:T}));return P}var FI=function(I){const T=I?.input?I.input:j.any(),P=I?.output?I.output:j.any(),F=I?.do.config?.input?I?.do.config?.input:j.any(),U=I?.do.config?.output?I?.do.config?.output:j.any();return G.merge(H(I)).merge(j.object({while:j.function(j.tuple([j.object({input:T,iteration:j.number()})]),j.union([j.boolean().promise(),j.boolean()])),do:j.instanceof(O),step:j.function(j.tuple([j.object({input:T,iteration:j.number()})]),j.union([F.promise(),F])),combine:j.function(j.tuple([j.object({input:T,output:P,result:U,iteration:j.number()})]),j.union([T.promise(),T]))}))};function x(I={}){return{_def:I,input(T){return x({...I,input:T})},output(T){return x({...I,output:T})},do(T){return x({...I,do:T})},build(){return new s(I)},step(T){return x({...I,step:T})},combine(T){return x({...I,combine:T})},while(T){return x({...I,while:T})}}}class s extends O{constructor(I){super({...I,run:PI});this.config=FI(this.config).parse(this.config)}}function p(I={}){return{_def:I,build(){return new d(I)}}}class d extends O{constructor(I){super({...I,run:({input:T})=>T})}}import X from"zod";async function OI({input:I}){if(await this.config.if({input:I}))return await this.config.then.exec({input:I});else return await this.config.else?.exec({input:I})??I}var UI=function(I){const T=I.then.config.input?I.then.config.input:X.any();return G.merge(H(I)).merge(X.object({if:X.function(X.tuple([X.object({input:T})]),X.union([X.boolean(),X.boolean().promise()])),then:X.instanceof(O),else:X.instanceof(O).optional()}))};function q(I={}){return{_def:I,if(T){return q({...I,if:T})},stage(T){return q({...I,then:T})},then(T){return q({...I,then:T})},else(T){return q({...I,else:T})},build(){return new g(I)}}}class g extends O{constructor(I){super({...I,run:OI});this.config=UI(this.config).parse(this.config)}}import $I from"lodash";import N from"zod";async function jI({input:I}){const T=await Promise.allSettled(this.config.cases.map((U)=>U.exec({input:I})));let P=[],F={};for(let U=0;U<T.length;U++){const J=T[U];if(J.status=="fulfilled")F=$I.defaultsDeep(F,{output:J.value});else P.push(new k({index:U,ctx:I[U],err:J.reason}))}if(P.length>0)throw W(P);return F.output}async function GI({input:I}){if(await this.config.evaluate({input:I}))return this.config.stage.execute(I);else return I}var HI=function(I){return G.merge(H(I)).merge(N.object({cases:N.array(N.instanceof(R))}))},JI=function(I){const T=I?.stage.config?.input?I?.stage.config?.input:N.any();return G.merge(H(I)).merge(N.object({evaluate:N.function(N.tuple([N.object({input:T})]),N.union([N.boolean().promise(),N.boolean()])),stage:N.instanceof(O)}))};function v(I={cases:[]}){return{_def:I,add(T){return I.cases.push(T),v({...I})},build(){return new a(I)}}}function A(I={}){return{_def:I,stage(T){return A({...I,stage:T})},evaluate(T){return A({...I,evaluate:T})},build(){return new R(I)}}}class a extends O{constructor(I){super({...I,run:jI});this.config=HI(this.config).parse(this.config)}}class R extends O{constructor(I){super({...I,run:GI});this.config=JI(this.config).parse(this.config)}}import C from"zod";async function KI(I){let T=0,P=I.input,F=I.input;while(T<this.config.stages.length)P=F=await this.config.stages[T++].exec({input:P});return F}var LI=function(I){return G.merge(H(I)).merge(C.object({stages:C.array(C.instanceof(O))}))};function b(I={stages:[]}){return{_def:I,addStage(T){return I.stages.push(T),b(I)},build(){return new u(I)}}}class u extends O{constructor(I){super({...I,run:KI});this.config=LI(this.config).parse(this.config)}}import V from"zod";async function NI({input:I}){try{return await this.config.stage.exec({input:I})}catch(T){const P=await this.config.rescue({error:T,input:I});if(!P)throw new Error(Z.rescue_MUST_return_value);return P}}var QI=function(I){const T=I.output?I.output:V.any(),P=I.input?I.input:V.any();return G.merge(H(I)).merge(V.object({stage:V.instanceof(O),rescue:V.function(V.tuple([V.object({error:V.union([V.instanceof(Error),V.undefined()]),input:P})]),V.union([T.promise(),T]))}))};function y(I={}){return{_def:I,stage(T){return y({...I,stage:T})},rescue(T){return y({...I,rescue:T})},build(){return new f(I)}}}class f extends O{constructor(I){super({...I,run:NI});this.config=QI(this.config).parse(this.config)}}import $ from"zod";var n=function({input:I}){return JSON.stringify({input:I})},VI=function({input:I,backup:T}){return JSON.parse(T).input};async function XI(I){let T=I.input;const P=async(E,l)=>{if(E)if(typeof this.config.retry==="function")return!await this.config.retry({error:E,input:T,iteration:l});else return l<(this.config.retry??1);else return!0};let F=void 0,U=0,J,z=this.config.backup?await this.config.backup({input:T}):n({input:T});while(U===0||await P(F,U)){if(U>0)T=this.config.restore?await this.config.restore({input:T,backup:z}):VI({input:T,backup:z});F=void 0;try{J=await this.config.stage.exec({input:T})}catch(E){F=E}U++}if(J)return J;throw new Error("no result recieved")}var YI=function(I){const T=I.stage.config.input?I.stage.config.input:$.any();return G.merge(H(I)).merge($.object({stage:$.instanceof(O),retry:$.union([$.function($.tuple([$.object({error:$.instanceof(Error),input:T,iteration:$.number()})]),$.union([$.boolean(),$.boolean().promise()])),$.number()]),backup:$.function($.tuple([$.object({input:T})]),$.union([$.any(),$.any().promise()])).optional(),restore:$.function($.tuple([$.object({input:T,backup:$.any()})]),$.union([T,T.promise()])).optional()}))};function B(I={}){return{_def:I,stage(T){return B({...I,stage:T})},retry(T){return B({...I,retry:T})},backup(T){return B({...I,backup:T})},restore(T){return B({...I,restore:T})},build(){return new o(I)}}}class o extends O{constructor(I){super({...I,run:XI});if(!this.config.backup)this.config.backup=n;this.config=YI(this.config).parse(this.config)}}import _ from"zod";async function ZI({input:I}){let T=[];for(let P=0;P<I.length;P++){const F=I[P],U=await this.config.stage.exec({input:F});T.push(U)}return T}async function xI({input:I}){const T=await Promise.allSettled(I.map((U)=>this.config.stage.exec({input:U})));let P=[],F=[];for(let U=0;U<T.length;U++){const J=T[U];if(J.status=="fulfilled")F.push(J.value);else P.push(new k({index:U,ctx:I[U],err:J.reason}))}if(P.length>0)throw W(P);return F}var DI=function(I){return G.merge(H(I)).merge(_.object({serial:_.boolean().optional(),stage:_.instanceof(O)}))};function S(I={}){return{_def:I,serial(){return S({...I,serial:!0})},stage(T){return S({...I,stage:T})},build(){return new r(I)}}}class r extends O{constructor(I){super({...I,run:I.serial?ZI:xI});this.config=DI(this.config).parse(this.config)}}var MI=function(I){return G.merge(H(I))};function h(I={}){return{_def:I,input(T){return h({...I,input:T})},output(T){return h({...I,output:T})},run(T){return h({...I,run:T})},build(){return new t(I)}}}class t extends O{constructor(I){const T=MI(I).parse(I);super(T)}}import Q from"zod";var qI=function(I){return new Promise((T)=>{setTimeout(()=>{T(!0)},I)})};async function BI({input:I}){const T=typeof this.config.timeout==="number"?this.config.timeout:await this.config.timeout({input:I}),P=await Promise.race([qI(T),this.config.stage.exec({input:I})]);if(typeof P==="boolean")if(this.config.overdue)return this.config.overdue.exec({input:I});else throw new Error(Z.operation_timeout_occured);else return P}var WI=function(I){const T=I.stage.config.input?I.stage.config.input:Q.any();return G.merge(H(I)).merge(Q.object({stage:Q.instanceof(O),overdue:Q.instanceof(O).optional(),timeout:Q.union([Q.number(),Q.function(Q.tuple([Q.object({input:T})]),Q.union([Q.number(),Q.number().promise()]))])}))};function m(I={}){return{_def:I,stage(T){return m({...I,stage:T})},overdue(T){return m({...I,overdue:T})},timeout(T){return m({...I,timeout:T})},build(){return new e(I)}}}class e extends O{constructor(I){super({...I,run:BI});this.config=WI(this.config).parse(this.config)}}import K from"zod";async function kI({input:I}){let T;if(this.config.prepare)T=await this.config.prepare({input:I});else T=I;const P=await this.config.stage.exec({input:T});let F;if(this.config.finalize)F=await this.config.finalize({input:I,data:P});else F=P;return F}var hI=function(I){const T=I?.output?I.output:K.any(),P=I?.input?I.input:K.any(),F=I?.stage.config?.input?I?.stage.config?.input:K.any(),U=I?.stage.config?.output?I?.stage.config?.output:K.any();return G.merge(H(I)).merge(K.object({stage:K.instanceof(O),prepare:K.function(K.tuple([K.object({input:P})]),K.union([F.promise(),F])),finalize:K.function(K.tuple([K.object({input:P,data:U})]),K.union([T.promise(),T]))}))};function D(I={}){return{_def:I,input(T){return D({...I,input:T})},output(T){return D({...I,output:T})},stage(T){return D({...I,stage:T})},build(){return new i(I)},prepare(T){return D({...I,prepare:T})},finalize(T){return D({...I,finalize:T})}}}class i extends O{constructor(I){super({...I,run:kI});this.config=hI(this.config).parse(this.config)}}function LP(){return{type(I){switch(!0){case I==="stage":return h();case I==="rescue":return y();case I==="wrap":return D();case I==="empty":return p();case I==="timeout":return m();case I==="ifelse":return q();case I==="retryonerror":return B();case I==="dowhile":return x();case I==="pipeline":return b();case I==="sequential":return S();case I==="multiwayswitch":return v();case I==="multiwayswitchcase":return A();default:throw new Error(Z.not_implemented)}}}}var QP=Symbol("unset");export{D as wrap,H as validatorRunConfig,c as validatorRun,G as validatorBaseStageConfig,QP as unsetMarker,m as timeout,h as stage,S as sequential,B as retryonerror,y as rescue,b as pipeline,A as multiwayswitchcase,v as multiwayswitch,wI as makeLegacyCallback,w as makeCallbackArgs,EI as makeCallback,II as isComplexError,mI as isCallbackArgs,q as ifelse,p as empty,x as dowhile,LP as builder,i as Wrap,e as Timeout,t as Stage,r as Sequential,o as RetryOnError,f as Rescue,u as Pipeline,k as ParallelError,R as MultiWaySwitchCase,a as MultiWaySwitch,g as IfElse,d as Empty,Z as ERROR,s as DoWhile,W as CreateError,M as ComplexError,O as AbstractStage};
